<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>上善若水</title>
    <link>https://xinetzone.github.io/</link>
    
    <atom:link href="https://xinetzone.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>利用 AI 开发一切有意思的东西</description>
    <pubDate>Fri, 07 May 2021 16:02:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>深度学习基础：线性回归</title>
      <link>https://xinetzone.github.io/xint/zh-CN/e12591eb9d76.html</link>
      <guid>https://xinetzone.github.io/xint/zh-CN/e12591eb9d76.html</guid>
      <pubDate>Fri, 07 May 2021 16:02:32 GMT</pubDate>
      
      <description>使用 TensorFlow，MXNet，PyTorch 实现线性回归</description>
      
      
      
      <content:encoded><![CDATA[<p>对 <span class="w3-yellow">样本</span> 做如下约定：</p><article>$$\tag{1} \mathbf{X} = \begin{bmatrix}\mathbf{x}_1^T \\ \mathbf{x}_2^T \\ \vdots \\ \mathbf{x}_m^T\end{bmatrix} \in \mathbb{R}^{m \times n} $$$$\begin{matrix}\tag{2}\mathbf{x}_i = \begin{bmatrix}x_{i1} \\ x_{i2} \\ \vdots \\ x_{in}\end{bmatrix} \in \mathbb{R}^n, &amp; i \in \{1, \cdots, m\}\end{matrix}$$</article><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><p>若有权重 $\mathbf{w} = (w_1, w_2, \cdots, w_n)^T \in \mathbb{R}^n$，偏置 $b \in \mathbb{R}$，则<span class="w3-yellow">线性模型</span>可以表示为：</p><article>$$\tag{3} \hat{\mathbf{y}} = \mathbf{Xw} + b \in \mathbb{R}^m$$</article><p>展开公式 (3)，即：</p><article>$$\begin{cases}\tag{4} \hat{\mathbf{y}} = (\hat{y}_1, \hat{y}_2, \cdots, \hat{y}_m)^T\\\hat{y}_i = \mathbf{x}_i^T \mathbf{w} + b = \langle \mathbf{x}_i, \mathbf{w} \rangle + b,&amp;i \in \{1, \cdots, m\}\end{cases}$$</article><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>已知样本 $(\mathbf{x}_i, y_i) _{i=1}^{m}$，且 $\mathbf{x}_i$ 的预测值为 $\hat{y_i}$，则定义可单个样本是损失函数：</p><article>$$\tag{5}l^{(i)}(\mathbf{w}, b) = \frac 1 2 (\hat{y}_i - y_i)^2, i \in \{1, \cdots, m\}$$</article><p>总损失函数定义为：</p><article>$$\tag{6}L(\mathbf{w}, b) = {\frac 1 m} \sum_{i=1}^m l^{(i)}(\mathbf{w}, b) = {\frac 1 {2m}} \lVert \mathbf{Xw} + b - \mathbf{y} \rVert ^2$$</article><p>在训练模型时，我们希望寻找一组参数 $(\mathbf{w}^*, b^*)$，这组参数能最小化在所有训练样本上的总损失。如下式：</p><article>$$\tag{7}\mathbf{w}^{\ast}, b^{\ast} = \argmax_{\mathbf{w}^{\ast}, b^{\ast}} L(\mathbf{w}, b)$$</article><p>可以求得解析解：</p><p>将 $\mathbf{w}$ 与 $b$ 合并为 $\overline{\mathbf{w}}$，$\overline{\mathbf{X}} = (\mathbf{X}, \mathbf{1})$，则公式 (6)，可以写作：</p><article>$$\tag{8}L(\mathbf{w}, b) = {\frac 1 {2m}} \lVert \overline{\mathbf{X}} \overline{\mathbf{w}} - \mathbf{y} \rVert ^2$$</article><p>这很容易求得解析解：</p><article>$$\tag{9}\overline{\mathbf{w}}^{\ast} = (\overline{\mathbf{X}}^T \overline{\mathbf{X}})^{-1} \overline{\mathbf{X}}^T \mathbf{y}$$</article><p>对于实际问题，往往模型很复杂很难求得解析解，大都仅仅求得其近似解。</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>由计算梯度得：</p><article>$$\tag{10}\nabla_{\overline{\mathbf{w}}} L = {\cfrac 1 m} \overline{\mathbf{X}}^T (\overline{\mathbf{X}} \overline{\mathbf{w}} - y)$$</article><p>所以，参数更新：</p><article>$$\tag{11}\begin{cases}\mathbf{w} \leftarrow \mathbf{w} - {\cfrac \eta m} \mathbf{X}^T (\mathbf{Xw} + b - \mathbf{y}) \\b \leftarrow b - {\frac \eta m} \mathbf{1}^T (\mathbf{Xw} + b - \mathbf{y})\end{cases}$$</article><p>其中 $\eta$ 表示学习率。</p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/xint/">xint</category>
      
      
      <category domain="https://xinetzone.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">线性回归</category>
      
      
      <comments>https://xinetzone.github.io/xint/zh-CN/e12591eb9d76.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://xinetzone.github.io/post/en-US/89a40920fbf4.html</link>
      <guid>https://xinetzone.github.io/post/en-US/89a40920fbf4.html</guid>
      <pubDate>Fri, 07 May 2021 16:02:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/%E6%95%99%E7%A8%8B/">教程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/hexo/">hexo</category>
      
      
      <comments>https://xinetzone.github.io/post/en-US/89a40920fbf4.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数学符号</title>
      <link>https://xinetzone.github.io/post/zh-CN/484dacbc2c0a.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/484dacbc2c0a.html</guid>
      <pubDate>Fri, 07 May 2021 16:02:32 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;数字&quot;&gt;&lt;a href=&quot;#数字&quot; class=&quot;headerlink&quot; title=&quot;数字&quot;&gt;&lt;/a&gt;数字&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;$x$：标量&lt;/li&gt;
&lt;li&gt;$\mathbf{x}$：向量&lt;/li&gt;
&lt;li&gt;$\mathbf{X}$：矩阵&lt;/li&gt;
&lt;l</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><ul><li>$x$：标量</li><li>$\mathbf{x}$：向量</li><li>$\mathbf{X}$：矩阵</li><li>$\mathsf{X}$：张量</li><li>$\mathbf{I}$：单位矩阵</li><li>$x_i$, $[\mathbf{x}]_i$：向量$\mathbf{x}$第$i$个元素</li><li>$x_{ij}$, $[\mathbf{X}]_{ij}$：矩阵$\mathbf{X}$第$i$行第$j$列的元素</li></ul><div class="w3-pale-green">向量、矩阵使用 <code>\mathbf</code>，张量使用 <code>\mathsf</code>。</div><h1 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h1><ul><li>$\mathcal{X}$: 集合</li><li>$\mathbb{Z}$: 整数集合</li><li>$\mathbb{R}$ 实数集合</li><li>$\mathbb{R}^n$: $n$维实数向量</li><li>$\mathbb{R}^{a\times b}$: 包含$a$行和$b$列的实数矩阵</li><li>$\mathcal{A}\cup\mathcal{B}$: 集合$\mathcal{A}$和$\mathcal{B}$的并集（<code>\cup</code>）</li><li>$\mathcal{A}\cap\mathcal{B}$：集合$\mathcal{A}$和$\mathcal{B}$的交集（<code>\cap</code>）</li><li>$\mathcal{A}\setminus\mathcal{B}$：集合$\mathcal{B}$与集合$\mathcal{A}$相减（<code>\setminus</code>）</li></ul><div class="w3-pale-green">集合使用 <code>\mathbb</code>，集合族使用 <code>\mathcal</code>。</div><h1 id="函数和运算符"><a href="#函数和运算符" class="headerlink" title="函数和运算符"></a>函数和运算符</h1><ul><li>$f(\cdot)$：函数</li><li>$\log(\cdot)$：自然对数</li><li>$\exp(\cdot)$: 指数函数</li><li>$\mathbf{1}_\mathcal{X}$: 指示函数</li><li>$\mathbf{(\cdot)}^\top$: 向量或矩阵的转置</li><li>$\mathbf{X}^{-1}$: 矩阵的逆</li><li>$\odot$: 按元素相乘</li><li>$[\cdot, \cdot]$：连结</li><li>$\lvert \mathcal{X} \rvert$：集合的基数</li><li>$|\cdot|_p$: ：$L_p$ 正则</li><li>$|\cdot|$: $L_2$ 正则</li><li>$\langle \mathbf{x}, \mathbf{y} \rangle$：向量$\mathbf{x}$和$\mathbf{y}$的点积</li><li>$\sum$: 连加</li><li>$\prod$: 连乘</li><li>$\stackrel{\mathrm{def}}{=}$：定义</li><li>$\ast$: 例如，$a^{\ast}$</li></ul><h1 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h1><ul><li>$\frac{dy}{dx}$：$y$关于$x$的导数</li><li>$\frac{\partial y}{\partial x}$：$y$关于$x$的偏导数</li><li>$\nabla_{\mathbf{x}} y$：$y$关于$\mathbf{x}$的梯度</li><li>$\int_a^b f(x) ;dx$: $f$在$a$到$b$区间上关于$x$的定积分</li><li>$\int f(x) ;dx$: $f$关于$x$的不定积分</li></ul><h1 id="概率与信息论"><a href="#概率与信息论" class="headerlink" title="概率与信息论"></a>概率与信息论</h1><ul><li>$P(\cdot)$：概率分布</li><li>$z \sim P$: 随机变量$z$具有概率分布$P$</li><li>$P(X \mid Y)$：$X\mid Y$的条件概率</li><li>$p(x)$: 概率密度函数</li><li>$\mathbb{E}_{x} [f(x)]$: 函数$f$对$x$的数学期望</li><li>$X \perp Y$: 随机变量$X$和$Y$是独立的</li><li>$X \perp Y \mid Z$: 随机变量$X$和$Y$在给定随机变量$Z$的条件下是独立的</li><li>$\mathrm{Var}(X)$: 随机变量$X$的方差</li><li>$\sigma_X$: 随机变量$X$的标准差</li><li>$\mathrm{Cov}(X, Y)$: 随机变量$X$和$Y$的协方差</li><li>$\rho(X, Y)$: 随机变量$X$和$Y$的相关性</li><li>$H(X)$: 随机变量$X$的熵</li><li>$D_{\mathrm{KL}}(P|Q)$: $P$和$Q$的KL-散度</li></ul><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>$\mathcal{O}$：大O标记</li></ul>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/%E6%95%B0%E5%AD%A6/">数学</category>
      
      
      <category domain="https://xinetzone.github.io/tags/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/">数学符号</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/484dacbc2c0a.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简单的梯度运算</title>
      <link>https://xinetzone.github.io/xint/zh-CN/9d900d55bcfe.html</link>
      <guid>https://xinetzone.github.io/xint/zh-CN/9d900d55bcfe.html</guid>
      <pubDate>Tue, 04 May 2021 08:44:49 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h2&gt;&lt;p&gt;有矩阵 $\mathbf{A} = [\mathbf{a}_1, \mathbf{a}_2, \cdots, \mathbf{a}_m]^T</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>有矩阵 $\mathbf{A} = [\mathbf{a}_1, \mathbf{a}_2, \cdots, \mathbf{a}_m]^T \in \mathbb{R}^{m \times n}$，和向量 $\mathbf{x} = [x_1, x_2, \cdots, x_n]^T \in \mathbb{R}^{n}$，则有：</p><div>$$\mathbf{Ax} = \begin{bmatrix}   \mathbf{a}_1^T \mathbf{x} \\   \mathbf{a}_2^T \mathbf{x} \\   \vdots \\   \mathbf{a}_m^T \mathbf{x}\end{bmatrix}$$</div><p>又有：</p><div>$$\nabla_{\mathbf{x}} \mathbf{a}_i^T \mathbf{x} = \mathbf{a}_i$$$$ \mathbf{1}^T \mathbf{A} \mathbf{x} = \langle \mathbf{1}, \mathbf{Ax} \rangle = \langle \mathbf{A}^T \mathbf{1}, \mathbf{x} \rangle$$</div><p>所以，</p><div>$$\nabla_{\mathbf{x}} \mathbf{1}^T \mathbf{A} \mathbf{x} = \nabla_{\mathbf{x}} \sum_{i=1}^m \mathbf{a}_i^T \mathbf{x} = \sum_{i=1}^m \mathbf{a}_i = \mathbf{A}^T \mathbf{1}_{m \times 1} = \mathbf{A}^T \mathbf{1}$$</div><p>这样，有：</p><div>$$\nabla_{\mathbf{x}} \mathbf{Ax} = \nabla_{\mathbf{x}} \langle  \mathbf{A}^T, \mathbf{x} \mathbf{1}^T \rangle = \mathbf{A}^T$$$$\nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{A} = \mathbf{A}$$$$\nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{A} \mathbf{x} = (\mathbf{A} + \mathbf{A}^\top)\mathbf{x}$$$$\nabla_{\mathbf{x}} \|\mathbf{x} \|^2 = \nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{x} = 2\mathbf{x}$$$$\nabla_{\mathbf{X}} \|\mathbf{X} \|_F^2 = 2\mathbf{X}$$</div><p>即：</p><div>$$\nabla_{\mathbf{x}} \langle f(\mathbf{x}), g(\mathbf{x}) \rangle = \langle \nabla{_\mathbf{x}} f(\mathbf{x}), g(\mathbf{x}) \rangle + \langle f(\mathbf{x}), \nabla_{\mathbf{x}} g(\mathbf{x}) \rangle$$</div><p>下面看一个例子：</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><article>    <div class="tab-set w3-light-grey">        <input checked="True" id="tab-set--0-input--1" name="tab-set--0" type="radio">        <label for="tab-set--0-input--1">MXNet</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> xint <span class="token keyword">import</span> utils<span class="token keyword">from</span> xint <span class="token keyword">import</span> mxnet <span class="token keyword">as</span> xintnp <span class="token operator">=</span> xint<span class="token punctuation">.</span>np<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>        </div>        <input id="tab-set--0-input--2" name="tab-set--0" type="radio">        <label for="tab-set--0-input--2">TensorFlow</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> xint <span class="token keyword">import</span> utils<span class="token keyword">from</span> xint <span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> xintnp <span class="token operator">=</span> xint<span class="token punctuation">.</span>np<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>        </div>        <input id="tab-set--0-input--3" name="tab-set--0" type="radio">        <label for="tab-set--0-input--3">PyTorch</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> xint <span class="token keyword">import</span> utils<span class="token keyword">from</span> xint <span class="token keyword">import</span> torch <span class="token keyword">as</span> xintnp <span class="token operator">=</span> xint<span class="token punctuation">.</span>np<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>        </div>    </div></article><p>创建张量 $\mathbf{x}$：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>计算函数 $y = 2\mathbf{x}^{\top}\mathbf{x}$ 的梯度：</p><article>    <div class="tab-set w3-light-grey">        <input checked="True" id="tab-set--1-input--1" name="tab-set--1" type="radio">        <label for="tab-set--1-input--1">MXNet</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 我们通过调用`attach_grad`来为一个张量的梯度分配内存</span>x<span class="token punctuation">.</span>attach_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 在我们计算关于`x`的梯度后，我们将能够通过'grad'属性访问它，它的值被初始化为0</span>x<span class="token punctuation">.</span>grad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>        </div>        <input id="tab-set--1-input--2" name="tab-set--1" type="radio">        <label for="tab-set--1-input--2">TensorFlow</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>        </div>        <input id="tab-set--1-input--3" name="tab-set--1" type="radio">        <label for="tab-set--1-input--3">PyTorch</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token comment"># 等价于 `x = torch.arange(4.0, requires_grad=True)`</span>x<span class="token punctuation">.</span>grad  <span class="token comment"># 默认值是None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>        </div>    </div></article><p>现在让计算 $y$：</p><div class="tab-set w3-light-grey">    <input checked="True" id="tab-set--2-input--1" name="tab-set--2" type="radio">    <label for="tab-set--2-input--1">MXNet</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> mxnet <span class="token keyword">import</span> autograd<span class="token comment"># 把代码放到`autograd.record`内，以建立计算图</span><span class="token keyword">with</span> autograd<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> x<span class="token punctuation">.</span>T @ x<span class="token builtin">float</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>    </div>    <input id="tab-set--2-input--2" name="tab-set--2" type="radio">    <label for="tab-set--2-input--2">TensorFlow</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 把所有计算记录在磁带上</span><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> tf<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>x<span class="token punctuation">)</span> @ x<span class="token builtin">float</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>    </div>    <input id="tab-set--2-input--3" name="tab-set--2" type="radio">    <label for="tab-set--2-input--3">PyTorch</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python">y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> x<span class="token punctuation">.</span>T @ x<span class="token builtin">float</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>    </div></div><p><output>28.0</output></p><p>接下来，我们可以通过调用反向传播函数来自动计算 $y$ 关于 $\mathbf{x}$ 每个分量的梯度，并打印这些梯度：</p><div class="tab-set w3-light-grey">    <input checked="True" id="tab-set--3-input--1" name="tab-set--3" type="radio">    <label for="tab-set--3-input--1">MXNet</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python">y<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>    <output>    array([[ 0.],       [ 4.],       [ 8.],       [12.]])</output>    </div>    <input id="tab-set--3-input--2" name="tab-set--3" type="radio">    <label for="tab-set--3-input--2">TensorFlow</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 把所有计算记录在磁带上</span><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> tf<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>x<span class="token punctuation">)</span> @ x<span class="token builtin">float</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>    <output>    &lt;tf.Tensor: shape=(4, 1), dtype=float64, numpy=    array([[ 0.],        [ 4.],        [ 8.],        [12.]])&gt;</output>    </div>    <input id="tab-set--3-input--3" name="tab-set--3" type="radio">    <label for="tab-set--3-input--3">PyTorch</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python">y<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>    <output>    tensor([[ 0.],        [ 8.],        [16.],        [24.]])</output>    </div></div><p>可以计算 $\mathbf{x}$ 的另一个函数：</p><div class="tab-set w3-light-grey">    <input checked="True" id="tab-set--4-input--1" name="tab-set--4" type="radio">    <label for="tab-set--4-input--1">MXNet</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> autograd<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    y <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>y<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad  <span class="token comment"># 被新计算的梯度覆盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>    <output>    array([[1.],       [1.],       [1.],       [1.]])    </output>    </div>    <input id="tab-set--4-input--2" name="tab-set--4" type="radio">    <label for="tab-set--4-input--2">TensorFlow</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    y <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_sum<span class="token punctuation">(</span>x<span class="token punctuation">)</span>t<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span>  <span class="token comment"># 被新计算的梯度覆盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>    <output>    &lt;tf.Tensor: shape=(4, 1), dtype=float64, numpy=    array([[1.],        [1.],        [1.],        [1.]])&gt;    </output>    </div>    <input id="tab-set--4-input--3" name="tab-set--4" type="radio">    <label for="tab-set--4-input--3">PyTorch</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 在默认情况下，PyTorch会累积梯度，我们需要清除之前的值</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>y <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>y<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>    <output>    tensor([[1.],        [1.],        [1.],        [1.]])    </output>    </div></div><p>注意：对于非标量变量的反向传播，MXNet/TensorFlow 直接调用相应的函数即可获得梯度，但是 Pytorch 不支持直接对非标量进行反向传播，故而需要先对其求和，再求梯度。比如：</p><div class="tab-set w3-light-grey">    <input checked="True" id="tab-set--5-input--1" name="tab-set--5" type="radio">    <label for="tab-set--5-input--1">MXNet</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 当我们对向量值变量`y`（关于`x`的函数）调用`backward`时，</span><span class="token comment"># 将通过对`y`中的元素求和来创建一个新的标量变量。然后计算这个标量变量相对于`x`的梯度</span><span class="token keyword">with</span> autograd<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    y <span class="token operator">=</span> x <span class="token operator">*</span> x  <span class="token comment"># `y`是一个向量</span>y<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad  <span class="token comment"># 等价于y = sum(x * x)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    </div>    <input id="tab-set--5-input--2" name="tab-set--5" type="radio">    <label for="tab-set--5-input--2">TensorFlow</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    y <span class="token operator">=</span> x <span class="token operator">*</span> xt<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span>  <span class="token comment"># 等价于 `y = tf.reduce_sum(x * x)`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>    </div>    <input id="tab-set--5-input--3" name="tab-set--5" type="radio">    <label for="tab-set--5-input--3">PyTorch</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对非标量调用`backward`需要传入一个`gradient`参数，该参数指定微分函数关于`self`的梯度。</span><span class="token comment">## 在我们的例子中，我们只想求偏导数的和，所以传递一个1的梯度是合适的</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>y <span class="token operator">=</span> x <span class="token operator">*</span> x<span class="token comment"># 等价于y.backward(torch.ones(len(x)))</span>y<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    </div></div><h2 id="分离计算"><a href="#分离计算" class="headerlink" title="分离计算"></a>分离计算</h2><p>有时，我们希望将某些计算移动到记录的计算图之外。例如，假设 $\mathbf{y}$ 是作为 $\mathbf{x}$ 的函数计算的，而 $\mathbf{z}$ 则是作为 $\mathbf{y}$ 和 $\mathbf{x}$ 的函数计算的。现在，想象一下，我们想计算 $\mathbf{z}$ 关于 $\mathbf{x}$ 的梯度，但由于某种原因，我们希望将 $\mathbf{y}$ 视为一个常数，并且只考虑到 $\mathbf{x}$ 在 $\mathbf{y}$ 被计算后发挥的作用。</p><p>在这里，我们可以分离 $\mathbf{y}$ 来返回一个新变量 $u$，该变量与 $\mathbf{y}$ 具有相同的值，但截断计算图中关于如何计算 $\mathbf{y}$ 的任何信息。换句话说，梯度不会向后流经 $u$ 到 $\mathbf{x}$。因此，下面的反向传播函数计算 $\mathbf{z} = u * \mathbf{x}$ 关于 $\mathbf{x}$ 的偏导数，同时将 $u$ 作为常数处理，而不是 $\mathbf{z} = \mathbf{x} * \mathbf{x} * \mathbf{x}$ 关于 $\mathbf{x}$ 的偏导数。</p><div class="tab-set w3-light-grey">    <input checked="True" id="tab-set--6-input--1" name="tab-set--6" type="radio">    <label for="tab-set--6-input--1">MXNet</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> autograd<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    y <span class="token operator">=</span> x <span class="token operator">*</span> x    u <span class="token operator">=</span> y<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span>    z <span class="token operator">=</span> u <span class="token operator">*</span> xz<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad <span class="token operator">==</span> u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    </div>    <input id="tab-set--6-input--2" name="tab-set--6" type="radio">    <label for="tab-set--6-input--2">TensorFlow</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 设置 `persistent=True` 来运行 `t.gradient`多次</span><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span>persistent<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">:</span>    y <span class="token operator">=</span> x <span class="token operator">*</span> x    u <span class="token operator">=</span> tf<span class="token punctuation">.</span>stop_gradient<span class="token punctuation">(</span>y<span class="token punctuation">)</span>    z <span class="token operator">=</span> u <span class="token operator">*</span> xx_grad <span class="token operator">=</span> t<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>z<span class="token punctuation">,</span> x<span class="token punctuation">)</span>x_grad <span class="token operator">==</span> u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    </div>    <input id="tab-set--6-input--3" name="tab-set--6" type="radio">    <label for="tab-set--6-input--3">PyTorch</label>    <div class="tab-content w3-padding">    <pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>y <span class="token operator">=</span> x <span class="token operator">*</span> xu <span class="token operator">=</span> y<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span>z <span class="token operator">=</span> u <span class="token operator">*</span> xz<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>grad <span class="token operator">==</span> u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    </div></div>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/xint/">xint</category>
      
      
      <category domain="https://xinetzone.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>https://xinetzone.github.io/xint/zh-CN/9d900d55bcfe.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>统一 MXNet，PyTorch，TensorFlow 接口</title>
      <link>https://xinetzone.github.io/xint/zh-CN/7a4a91cc735e.html</link>
      <guid>https://xinetzone.github.io/xint/zh-CN/7a4a91cc735e.html</guid>
      <pubDate>Tue, 04 May 2021 02:44:11 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;为了提供一个统一的接口，我在 GitHub 上维护了一个通用 API：&lt;a href=&quot;https://github.com/xinetzone/atom&quot;&gt;atom&lt;/a&gt;。可以使用 &lt;code&gt;pip&lt;/code&gt; 安装。本仓库借鉴了 &lt;a href=&quot;https://</description>
        
      
      
      
      <content:encoded><![CDATA[<p>为了提供一个统一的接口，我在 GitHub 上维护了一个通用 API：<a href="https://github.com/xinetzone/atom">atom</a>。可以使用 <code>pip</code> 安装。本仓库借鉴了 <a href="https://zh-v2.d2l.ai/">d2l</a> 和 <a href="https://tf.wiki/zh_hans/">简单粗暴 TensorFlow 2</a>。</p><p>首先导入一些库：</p><article>    <div class="tab-set w3-light-grey">        <input checked="True" id="tab-set--0-input--1" name="tab-set--0" type="radio">        <label for="tab-set--0-input--1">MXNet</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> xint <span class="token keyword">import</span> utils<span class="token keyword">from</span> xint <span class="token keyword">import</span> mxnet <span class="token keyword">as</span> xintnp <span class="token operator">=</span> xint<span class="token punctuation">.</span>np<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>        </div>        <input id="tab-set--0-input--2" name="tab-set--0" type="radio">        <label for="tab-set--0-input--2">TensorFlow</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> xint <span class="token keyword">import</span> utils<span class="token keyword">from</span> xint <span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> xintnp <span class="token operator">=</span> xint<span class="token punctuation">.</span>np<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>        </div>        <input id="tab-set--0-input--3" name="tab-set--0" type="radio">        <label for="tab-set--0-input--3">PyTorch</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> xint <span class="token keyword">import</span> utils<span class="token keyword">from</span> xint <span class="token keyword">import</span> torch <span class="token keyword">as</span> xintnp <span class="token operator">=</span> xint<span class="token punctuation">.</span>np<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>        </div>    </div></article><h2 id="简单的使用-atom"><a href="#简单的使用-atom" class="headerlink" title="简单的使用 atom"></a>简单的使用 atom</h2><p>由于 <code>np</code> 已经绑定了各自的深度学习环境，且三种框架及其相似，所以，下文如果框架之间没有分歧，统一使用没有指示环境的模式，比如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">10000</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>n<span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你可以分别查看各自环境的数据：</p><article>    <div class="tab-set w3-light-grey">        <input checked="True" id="tab-set--0-input--4" name="tab-set--1" type="radio">        <label for="tab-set--0-input--4">MXNet</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>            <output>array([1., 1., 1., ..., 1., 1., 1.])</output>        </div>        <input id="tab-set--0-input--5" name="tab-set--1" type="radio">        <label for="tab-set--0-input--5">TensorFlow</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>            <output>&lt;ndarray&lt;&lt;tf.Tensor: shape=(10000,), dtype=float64, numpy=array([1., 1., 1., ..., 1., 1., 1.])&gt;&gt;</output>        </div>        <input id="tab-set--0-input--6" name="tab-set--1" type="radio">        <label for="tab-set--0-input--6">PyTorch</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>            <output>tensor([1., 1., 1.,  ..., 1., 1., 1.])</output>        </div>    </div></article><p>可以看到不同环境表示的不同的 <code>np</code>，可以无缝的使用它。</p><p><code>atom</code> 定义了一个计时器 <code>Timer</code>，下面测试矢量化的好处。</p><ol><li>使用 <code>for</code> 循环：</li></ol><article>    <div class="tab-set w3-light-grey">        <input checked="True" id="tab-set--0-input--7" name="tab-set--2" type="radio">        <label for="tab-set--0-input--7">MXNet</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python">c <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span>timer <span class="token operator">=</span> utils<span class="token punctuation">.</span>Timer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>timer<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token format-spec">.5f</span><span class="token punctuation">}</span></span><span class="token string"> sec'</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>            <output>'2.83601 sec'</output>        </div>        <input id="tab-set--0-input--8" name="tab-set--2" type="radio">        <label for="tab-set--0-input--8">TensorFlow</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tfc <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>timer <span class="token operator">=</span> utils<span class="token punctuation">.</span>Timer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>assign<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>timer<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token format-spec">.5f</span><span class="token punctuation">}</span></span><span class="token string"> sec'</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>            <output>'3.42657 sec'</output>        </div>        <input id="tab-set--0-input--9" name="tab-set--2" type="radio">        <label for="tab-set--0-input--9">PyTorch</label>        <div class="tab-content w3-padding">            <pre class="line-numbers language-python" data-language="python"><code class="language-python">c <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span>timer <span class="token operator">=</span> utils<span class="token punctuation">.</span>Timer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>timer<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token format-spec">.5f</span><span class="token punctuation">}</span></span><span class="token string"> sec'</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>            <output>'0.13695 sec'</output>        </div>    </div></article><ol start="2"><li>使用重载的 <code>+</code> 运算符来计算按张量的和。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">timer<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>timer<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token format-spec">.9f</span><span class="token punctuation">}</span></span><span class="token string"> sec'</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出的时间有点差异，但是都很快：</p><article>    <div class="tab-set w3-light-grey">        <input checked="True" id="tab-set--0-input--10" name="tab-set--3" type="radio">        <label for="tab-set--0-input--10">MXNet</label>        <div class="tab-content w3-padding">            <output>'0.0009992 sec'</output>        </div>        <input id="tab-set--0-input--11" name="tab-set--3" type="radio">        <label for="tab-set--0-input--11">TensorFlow</label>        <div class="tab-content w3-padding">            <output>'0.000999451 sec'</output>        </div>        <input id="tab-set--0-input--12" name="tab-set--3" type="radio">        <label for="tab-set--0-input--12">PyTorch</label>        <div class="tab-content w3-padding">            <output>'0.000944614 sec'</output>        </div>    </div></article><p>可以看出矢量化对运算速度的提升是数量级的。</p><h2 id="正态分布与平方损失"><a href="#正态分布与平方损失" class="headerlink" title="正态分布与平方损失"></a>正态分布与平方损失</h2><p><strong>正态分布</strong>（normal distribution），也被称为 <strong>高斯分布</strong>（Gaussian distribution），最早由德国数学家高斯（Gauss）应用于天文学研究。简单的说，若随机变量 $x$ 具有均值 $\mu$ 和方差 $\sigma^2$（标准差 $\sigma$），其正态分布概率密度函数如下：</p><section>$$p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (x - \mu)^2\right).$$</section><p>使用 <code>np</code> 可以实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">normal</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> mu<span class="token punctuation">,</span> sigma<span class="token punctuation">)</span><span class="token punctuation">:</span>    p <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi <span class="token operator">*</span> sigma<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> p <span class="token operator">*</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span> <span class="token operator">/</span> sigma<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> mu<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可视化正态分布：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token comment"># 均值和标准差对</span>params <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>utils<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">[</span>normal<span class="token punctuation">(</span>x<span class="token punctuation">,</span> mu<span class="token punctuation">,</span> sigma<span class="token punctuation">)</span> <span class="token keyword">for</span> mu<span class="token punctuation">,</span> sigma <span class="token keyword">in</span> params<span class="token punctuation">]</span><span class="token punctuation">,</span> xlabel<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span>           ylabel<span class="token operator">=</span><span class="token string">'p(x)'</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>           legend<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string-interpolation"><span class="token string">f'mean </span><span class="token interpolation"><span class="token punctuation">{</span>mu<span class="token punctuation">}</span></span><span class="token string">, std </span><span class="token interpolation"><span class="token punctuation">{</span>sigma<span class="token punctuation">}</span></span><span class="token string">'</span></span> <span class="token keyword">for</span> mu<span class="token punctuation">,</span> sigma <span class="token keyword">in</span> params<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><output></output><img src="/dao/xint/zh-CN/7a4a91cc735e/output_2_0.svg"></p><p>改变均值会产生沿 $x$ 轴的偏移，增加方差将会分散分布、降低其峰值。</p><p>利用<strong>均方误差损失</strong>函数（简称<strong>均方损失</strong>）可以用于线性回归的一个原因是：假设观测 $\mathbf{x}$ 中包含噪声，其中噪声服从正态分布。噪声正态分布如下式:</p><section>$$\tag{1.1} y = \mathbf{w}^\top \mathbf{x} + b + \epsilon \text{ where } \epsilon \sim \mathcal{N}(0, \sigma^2).$$</section><p>因此，我们现在可以写出通过给定的观测 $\mathbf{x}$  到特定 $y$ 的似然（likelihood）：</p><section>$$\tag{1.2} P(y \mid \mathbf{x}) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (y - \mathbf{w}^\top \mathbf{x} - b)^2\right).$$</section><p>根据最大似然估计法，参数 $\mathbf{w}$ 和 $b$ 的最优值是使整个数据集的似然最大的值：</p><section>$$\tag{1.3} P(\mathbf y \mid \mathbf X) = \prod_{i=1}^{n} p(y^{(i)}|\mathbf{x}^{(i)}).$$</section><p>根据最大似然估计法选择的估计量称为<strong>最大似然估计量</strong> 。为了更好的计算，可以<strong>最小化负对数似然</strong> $-\log P(\mathbf y \mid \mathbf X)$。由此可以得到的数学公式是：</p><section>$$\tag{1.4} -\log P(\mathbf y \mid \mathbf X) = \sum_{i=1}^n \frac{1}{2} \log(2 \pi \sigma^2) + \frac{1}{2 \sigma^2} \left(y^{(i)} - \mathbf{w}^\top \mathbf{x}^{(i)} - b\right)^2.$$</section><p>现在我们只需要假设 $\sigma$ 是某个固定常数就可以忽略第一项，因为第一项不依赖于 $\mathbf{w}$ 和 $b$。现在第二项除了常数 $\frac{1}{\sigma^2}$ 外，其余部分和前面介绍的平方误差损失是一样的。因此，<span class="w3-card w3-pale-blue">在高斯噪声的假设下，最小化均方误差等价于对线性模型的最大似然估计</span>。</p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/xint/">xint</category>
      
      
      <category domain="https://xinetzone.github.io/tags/Python/">Python</category>
      
      <category domain="https://xinetzone.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>https://xinetzone.github.io/xint/zh-CN/7a4a91cc735e.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo-github-pages</title>
      <link>https://xinetzone.github.io/post/zh-CN/23dd9200e1e9.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/23dd9200e1e9.html</guid>
      <pubDate>Fri, 30 Apr 2021 15:23:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;参考 &lt;a href=&quot;https://hexo.io/docs/github-pages&quot;&gt;GitHub Pages | Hexo&lt;/a&gt; 配置。&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>参考 <a href="https://hexo.io/docs/github-pages">GitHub Pages | Hexo</a> 配置。</p>]]></content:encoded>
      
      
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/23dd9200e1e9.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微精通</title>
      <link>https://xinetzone.github.io/mircromastery/zh-CN/f0e28335bb89.html</link>
      <guid>https://xinetzone.github.io/mircromastery/zh-CN/f0e28335bb89.html</guid>
      <pubDate>Fri, 30 Apr 2021 00:09:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;发掘兴趣+识别重心+立体学习+内行经验=无限可能&lt;/p&gt;
&lt;p&gt;《微精通》 作者：罗伯特．特威格尔&lt;/p&gt;
&lt;h2 id=&quot;什么是“微精通”&quot;&gt;&lt;a href=&quot;#什么是“微精通”&quot; class=&quot;headerlink&quot; title=&quot;什么是“微精通”&quot;&gt;&lt;/a&gt;什么是“微</description>
        
      
      
      
      <content:encoded><![CDATA[<p>发掘兴趣+识别重心+立体学习+内行经验=无限可能</p><p>《微精通》 作者：罗伯特．特威格尔</p><h2 id="什么是“微精通”"><a href="#什么是“微精通”" class="headerlink" title="什么是“微精通”"></a>什么是“微精通”</h2><p><dfn class="xin-term">微精通</dfn> 是一种完整、独立的<strong>实践体系</strong>，但也可以扩展到更大的领域中。</p><p>你可以先精通一件小事儿，然后把它做大，也可以二者都做。</p><p><dfn class="xin-term">微精通</dfn> 可被<strong>复验</strong>，且往往<strong>能够取得成功</strong>。它的实践本身就是令人愉悦的过程。你可以试着去实践。<br><dfn class="xin-term">微精通</dfn>，它有一定的弹性，可以对其进行调整。同时，当你用一种三维立体的方法开展学习时，大脑中的各种感觉神经元也会被调动起来，变得活跃。</p><div class="w3-pale-yellow w3-card-4">心理学家米哈里·契克森米哈赖定义 <dfn class="xin-term">心流</dfn> 为一种将个体注意力完全投注在某活动上的感觉；心流产生时同时会有高度的兴奋及充实感。</div><div class="w3-pale-yellow w3-margin-top w3-card-4"><p><dfn class="xin-term">精神熵</dfn>（psychic entropy）：参考物理学中的熵，精神熵是用于衡量意识的无序程度的。每当资讯对意识本身的信息构成威胁，就会发生内在失序的现象，这种失序会造成意识的混乱和无序。为了衡量这种意识的混乱程度，米哈里提出了精神熵的概念。</p><p>对于我们个人而言，如果长期的意识混乱和精力不集中，并且自身没有对于意识和注意力的管理。那么如果这种情况维持过久，意识会越来越无序，越来越无法集中注意力，势必会对自己的工作与生活产生不小的影响。</p><p>而精神熵的反面就是有序的意识，米哈里把这种有序的意识称之为“最优体验”，也应用于用户体验和交互设计领域。在最优体验种，意识形成良性的循环，注意力得到集中，工作效率得到提升，对外干扰事物的感知降低，甚至达到忘我的境界。</p></div><p>米哈里提出了<strong>构成心流的要素</strong>：</p><ol class="w3-pale-yellow w3-margin-top w3-card-4"><li><span class="w3-pale-blue">一个可量化的目标</span>：目标是明确可以衡量的，或者说无法完成的目标是无法提供乐趣的，只有挫折和无望。目标是符合 SMART 原则的：明确（Specific）, 可衡量（Measurable）, 可达成（Achievable）, 相关（Relevant）, 时限（Time-bound）。</li><li><span class="w3-pale-blue">目标具有挑战性</span>：不具有挑战性的目标只消耗极少的注意力资源，无法使人专注其中。</li><li><span class="w3-pale-blue">自身具备一定能力</span>：在挑战的过程中，自身应当具备可能完成目标的能力，同时目标难度应当适当高出自身所具备的能力。当能力与挑战难度不相匹配，容易产生轻易感或是失落感。对于能力和挑战难度的关系如下图所示。</li><li><span class="w3-pale-blue">集中注意力</span>：达到最优体验状态需要集中注意力，而且深沉的快乐是严格的自律和集中注意力换来的。</li><li><span class="w3-pale-blue">挑战的过程反馈及时</span>：缺少反馈的过程是茫然的、无助的、也是无趣的。反馈作为用户体验闭环中的重要环节，既给用户带来信息的感知和内心的感受，同时也可以作为奖励而存在。</li></ol><p><img src="/dao/mircromastery/zh-CN/f0e28335bb89/aa.png"></p><p>既然精神熵代表意识的混乱程度，而心流则表示意识的有序，那么我们追寻心流的过程可以认为是“管理意识”的过程，也是“降熵”的过程。</p><p>微精通并不是让你遵循让人失去活力的方法（比如购买入门教科书），也并不意味着你必须做那些似乎永远做不完的事情。它的<strong>有限性</strong>能够让你对这个世界保持兴趣，同时消除焦虑，不会让你觉得浪费了很多时间。</p><p>微精通的结构以一种关键方法，在更广泛的领域中与诸多重要元素想关联。（建立联系）</p><div class="w3-pale-green w3-card-4 w3-padding">在一项微精通中，仅用少量的文字就能揭示各个元素间的关联和平衡关系。</div><p>微精通具有可<strong>复验性</strong>，<strong>游戏性</strong>，<strong>人人可为性</strong>。</p><p>如果在学习过程中不能获得一系列微小的成功，你将失去信心，甚至放弃，特别是在完全自学的情况下。</p><h2 id="微精通内核"><a href="#微精通内核" class="headerlink" title="微精通内核"></a>微精通内核</h2><p>依据必要的（微精通）结构来管理学习进程，并最终实现目标。</p><p>每一种微精通都有精确的结构：</p><ol><li>入门技巧</li><li>协同障碍</li><li>背景支持</li><li>成功回报</li><li>可复验性</li><li>可实验性</li></ol><h3 id="入门技巧"><a href="#入门技巧" class="headerlink" title="入门技巧"></a>入门技巧</h3><p>入门技巧是<strong>如何使你迈开步子走上微精通之路的</strong>。入门技巧可以为你克服微精通实践初期存在的障碍，比如增强自信心和熟悉程度，或者，让你针对学习过程中的每一部分分配合适的重视程度。</p><p>入门技巧能够让你快速地对事物有个基本的把握，虽然到最后阶段时你可能就不需要它了，不过在最初阶段，它是你最好的朋友。</p><p>入门技巧可以有很多的形式。比如：</p><ul><li>一些简单的改进方法</li><li>专注训练某一方面</li><li>对某些事情加以特别关注</li></ul><p>入门技巧的益处：</p><ul><li>使你能够很投入地做事情，你安心地告诉自己，知道技巧就能做了。</li><li>即使不能很快做好，起码可以提高速度，让你有耐心忍受长达几个小时的练习。</li></ul><p>随着学习的推进，或许到某个节点时，你会发现自己不再需要这些技巧了，这说明它们已经完成助你走向完美微精通的光荣使命。</p><h3 id="协同障碍"><a href="#协同障碍" class="headerlink" title="协同障碍"></a>协同障碍</h3>]]></content:encoded>
      
      
      
      <category domain="https://xinetzone.github.io/tags/mircromastery/">mircromastery</category>
      
      
      <comments>https://xinetzone.github.io/mircromastery/zh-CN/f0e28335bb89.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>网络编程基础：socket</title>
      <link>https://xinetzone.github.io/python/zh-CN/31ee077c5c0f.html</link>
      <guid>https://xinetzone.github.io/python/zh-CN/31ee077c5c0f.html</guid>
      <pubDate>Thu, 22 Apr 2021 05:52:25 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;socket&lt;/code&gt;模块（底层网络接口）提供了访问 BSD 套接字 的接口。在所有现代 Unix 系统、Windows、macOS 和其他一些平台上可用。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; t</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>socket</code>模块（底层网络接口）提供了访问 BSD 套接字 的接口。在所有现代 Unix 系统、Windows、macOS 和其他一些平台上可用。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Socket 又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。这个 Python 接口是用 Python 的面向对象风格对 Unix 系统调用和套接字库接口的直译：函数 <code>socket()</code> 返回一个 <strong>套接字对象</strong>，其方法是对各种套接字系统调用的实现。形参类型一般与 C 接口相比更高级：例如在 Python 文件 <code>read()</code> 和 <code>write()</code> 操作中，接收操作的缓冲区分配是自动的，发送操作的缓冲区长度是隐式的。</p><ul><li>模块 <a href="https://docs.python.org/zh-cn/3.10/library/socketserver.html#module-socketserver">socketserver</a>：用于简化网络服务端编写的类。</li><li>模块 <a href="https://docs.python.org/zh-cn/3.10/library/ssl.html#module-ssl">ssl</a>：套接字对象的TLS/SSL封装。</li></ul><h2 id="套接字协议族"><a href="#套接字协议族" class="headerlink" title="套接字协议族"></a>套接字协议族</h2><p>根据系统以及构建选项，<code>socket</code>模块提供了各种套接字协议簇。</p><p><strong>协议</strong>（Protocol）就是网络通信过程中的约定或者合同，通信的双方必须都遵守才能正常收发数据。协议有很多种，例如 TCP、UDP、IP 等，通信的双方必须使用同一协议才能通信。协议是一种规范，由计算机组织制定，规定了很多细节，例如，如何建立连接，如何相互识别等。</p><blockquote><p>协议仅仅是一种规范，必须由计算机软件来实现。例如 IP 协议规定了如何找到目标计算机，那么各个开发商在开发自己的软件时就必须遵守该协议，不能另起炉灶。</p></blockquote><p>TCP/IP 模型包含了 TCP、IP、UDP、Telnet、FTP、SMTP 等上百个互为关联的协议，其中 TCP 和 IP 是最常用的两种底层协议，所以把它们统称为“TCP/IP 协议族”。它们的层级关系如下图所示：</p><p><img src="/dao/python/zh-CN/31ee077c5c0f/q.gif"></p><p>我们平常使用的程序（或者说软件）一般都是通过应用层来访问网络的，程序产生的数据会一层一层地往下传输，直到最后的网络接口层，就通过网线发送到互联网上去了。数据每往下走一层，就会被这一层的协议增加一层包装，等到发送到互联网上时，已经比原始数据多了四层包装。整个数据封装的过程就像俄罗斯套娃。</p><p>当另一台计算机接收到数据包时，会从网络接口层再一层一层往上传输，每传输一层就拆开一层包装，直到最后的应用层，就得到了最原始的数据，这才是程序要使用的数据。</p><p>给数据加包装的过程，实际上就是在数据的头部增加一个标志（一个数据块），表示数据经过了这一层，我已经处理过了。给数据拆包装的过程正好相反，就是去掉数据头部的标志，让它逐渐现出原形。</p><p>两台计算机进行通信时，必须遵守以下原则：</p><ul><li>必须是同一层次进行通信，比如，A 计算机的应用层和 B 计算机的传输层就不能通信，因为它们不在一个层次，数据的拆包会遇到问题。</li><li>每一层的功能都必须相同，也就是拥有完全相同的网络模型。如果网络模型都不同，那不就乱套了，谁都不认识谁。</li><li>数据只能逐层传输，不能跃层。</li><li>每一层可以使用下层提供的服务，并向上层提供服务。</li></ul><p>路由器用来完成 IP 层的交互任务。某个网络原来使用 A 公司的路由器，现要将其替换成 B 公司的，是否可行？这并非难事，并不一定要换成同一公司的同一型号路由器，因为所有生产商都会按照 IP 层标准制造。再举个例子。大家的计算机是否装有网络接口卡，也就是所谓的网卡？尚未安装也无妨，其实很容易买到，因为所有网卡制造商都会遵守链路层的协议标准。这就是开放式系统的优点。</p><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>IP 地址是 Internet Protocol Address 的缩写，译为“网际协议地址”。一台计算机可以拥有一个独立的 IP 地址，一个局域网也可以拥有一个独立的 IP 地址（对外就好像只有一台计算机）。对于目前广泛使用 IPv4 地址，它的资源是非常有限的，一台计算机一个 IP 地址是不现实的，往往是一个局域网才拥有一个 IP 地址。</p><p>在因特网上进行通信时，必须要知道对方的 IP 地址。实际上数据包中已经附带了 IP 地址，把数据包发送给路由器以后，路由器会根据 IP 地址找到对方的地里位置，完成一次数据的传递。路由器有非常高效和智能的算法，很快就会找到目标计算机。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>现实的情况是，一个局域网往往才能拥有一个独立的 IP；换句话说，IP 地址只能定位到一个局域网，无法定位到具体的一台计算机。这可怎么办呀？这样也没法通信啊。</p><p>其实，真正能唯一标识一台计算机的是 MAC 地址，每个网卡的 MAC 地址在全世界都是独一无二的。计算机出厂时，MAC 地址已经被写死到网卡里面了（当然通过某些“奇巧淫技”也是可以修改的）。局域网中的路由器/交换机会记录每台计算机的 MAC 地址。</p><blockquote><p>MAC 地址是 Media Access Control Address 的缩写，直译为“媒体访问控制地址”，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address）。</p></blockquote><p>数据包中除了会附带对方的 IP 地址，还会附带对方的 MAC 地址，当数据包达到局域网以后，路由器/交换机会根据数据包中的 MAC 地址找到对应的计算机，然后把数据包转交给它，这样就完成了数据的传递。</p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>有了 IP 地址和 MAC 地址，虽然可以找到目标计算机，但仍然不能进行通信。一台计算机可以同时提供多种网络服务，例如 Web 服务（网站）、FTP 服务（文件传输服务）、SMTP 服务（邮箱服务）等，仅有 IP 地址和 MAC 地址，计算机虽然可以正确接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。</p><p>为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web 服务的端口号是 80，FTP 服务的端口号是 21，SMTP 服务的端口号是 25。</p><p>端口（Port）是一个虚拟的、逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同的编号，就是端口号。</p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/web/">web</category>
      
      
      <comments>https://xinetzone.github.io/python/zh-CN/31ee077c5c0f.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>高级 I/O 复用库</title>
      <link>https://xinetzone.github.io/python/zh-CN/c7565b5b6ae3.html</link>
      <guid>https://xinetzone.github.io/python/zh-CN/c7565b5b6ae3.html</guid>
      <pubDate>Thu, 22 Apr 2021 04:57:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;参考自：&lt;a href=&quot;https://docs.python.org/3.10/library/selectors.html&quot;&gt;selectors — High-level I/O multiplexing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;selectors&lt;/cod</description>
        
      
      
      
      <content:encoded><![CDATA[<p>参考自：<a href="https://docs.python.org/3.10/library/selectors.html">selectors — High-level I/O multiplexing</a></p><p><code>selectors</code> 模块允许高层级且高效率的 I/O 复用，它建立在 <code>select</code> 模块原型的基础之上，提供基于 <code>select</code> 模块的 I/O 复用的平台无关的抽象。推荐使用 <code>selectors</code> 模块，除非希望对所使用的 OS 层级原型进行精确控制。它定义了一个 <code>BaseSelector</code> 抽象基类，以及多个实际的实现 (<a href="https://docs.python.org/zh-cn/3.10/library/selectors.html#selectors.KqueueSelector" title="selectors.KqueueSelector"><code>KqueueSelector</code></a>,&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/selectors.html#selectors.EpollSelector" title="selectors.EpollSelector"><code>EpollSelector</code></a>…)，它们可被用于在多个文件对象上等待 I/O 就绪通知。 在下文中，”文件对象” 是指任何具有 <code>fileno()</code> 方法的对象，或是一个原始文件描述器。参见 <a href="https://docs.python.org/3.10/glossary.html#term-file-object">file object</a>。</p><div class="w3-pale-green w3-card w3-padding"><p><dfn class="xin-term">文件对象</dfn>（file object）：对外提供面向文件 API 以使用下层资源的对象（带有 <code>read()</code> 或 <code>write()</code> 这样的方法）。根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等等）。文件对象也被称为 <strong>file-like objects</strong> 或 <strong>流</strong>（streams）。</p><p>实际上共有三种类别的文件对象: 原始 <a href="https://docs.python.org/3.10/glossary.html#term-binary-file">二进制文件</a>, 被缓冲的 <a href="https://docs.python.org/3.10/glossary.html#term-binary-file">二进制文件</a> 以及 <a href="https://docs.python.org/3.10/glossary.html#term-text-file">文本文件</a>。它们的接口定义均在 <code>io</code> 模块中。创建文件对象的规范方式是使用 <code><a href="https://docs.python.org/3.10/library/functions.html#open">open()</a></code> 函数。</p></div><p><code>DefaultSelector</code> 是一个指向当前平台上可用的最高效实现的别名：这应为大多数用户的默认选择。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> _can_use<span class="token punctuation">(</span><span class="token string">'kqueue'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    DefaultSelector <span class="token operator">=</span> KqueueSelector<span class="token keyword">elif</span> _can_use<span class="token punctuation">(</span><span class="token string">'epoll'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    DefaultSelector <span class="token operator">=</span> EpollSelector<span class="token keyword">elif</span> _can_use<span class="token punctuation">(</span><span class="token string">'devpoll'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    DefaultSelector <span class="token operator">=</span> DevpollSelector<span class="token keyword">elif</span> _can_use<span class="token punctuation">(</span><span class="token string">'poll'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    DefaultSelector <span class="token operator">=</span> PollSelector<span class="token keyword">else</span><span class="token punctuation">:</span>    DefaultSelector <span class="token operator">=</span> SelectSelector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下文中，<code>events</code> 一个位掩码，指明哪些 I/O 事件要在给定的文件对象上执行等待。它可以是以下模块级常量的组合:</p><table><thead><tr><th align="center">常量</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">EVENT_READ</td><td align="center">可读</td></tr><tr><td align="center">EVENT_WRITE</td><td align="center">可写</td></tr></tbody></table><h2 id="class-selectors-SelectorKey"><a href="#class-selectors-SelectorKey" class="headerlink" title="class selectors.SelectorKey"></a>class selectors.SelectorKey</h2><p><code>SelectorKey</code> 是一个 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.namedtuple">namedtuple</a>，用来将文件对象关联到其隐含的文件描述器、选定事件掩码和附加数据等。它会被某些 <code>BaseSelector</code> 方法返回。</p><dl class="w3-pale-yellow w3-card-4 w3-padding"> <dt class="w3-pale-green w3-card-4">fileobj</dt> <dd>已注册的文件对象</dd> <dt class="w3-pale-green w3-card-4">fd</dt> <dd>隐含的的文件描述器（Underlying file descriptor）</dd> <dt class="w3-pale-green w3-card-4">events</dt> <dd>必须在此文件对象上被等待的事件</dd> <dt class="w3-pale-green w3-card-4">data</dt> <dd>可选的关联到此文件对象的不透明数据：例如，这可被用来存储各个客户端的会话 ID</dd></dl><h2 id="class-selectors-BaseSelector"><a href="#class-selectors-BaseSelector" class="headerlink" title="class selectors.BaseSelector"></a>class selectors.BaseSelector</h2><p>一个 <code>BaseSelector</code>，用来在多个文件对象上等待 I/O 事件就绪。它支持文件流注册、注销，以及在这些流上等待 I/O 事件的方法。它是一个抽象基类，因此不能被实例化。请改用 <code>DefaultSelector</code>，或者 <code>SelectSelector</code>, <code>KqueueSelector</code> 等。如果你想要指明使用某个实现，并且你的平台支持它的话。<code>BaseSelector</code> 及其具体实现支持 <a href="https://docs.python.org/3.10/glossary.html#term-context-manager">context manager</a> 协议。</p><dl class="w3-pale-yellow w3-card-4 w3-padding"> <dt class="w3-pale-green w3-card-4">abstractmethod register(fileobj, events, data=None)</dt> <dd>注册一个用于选择的文件对象，在其上监视 I/O 事件。</dd> <dd><code>fileobj</code> 是要监视的文件对象。它可以是整数形式的文件描述符或者具有 <code>fileno()</code> 方法的对象。<code>events</code> 是要监视的事件的位掩码。<code>data</code> 是一个不透明对象。</dd> <dd>这将返回一个新的 <code>SelectorKey</code> 实例，或在出现无效事件掩码或文件描述符时引发 <code>ValueError</code>，或在文件对象已被注册时引发 <code>KeyError</code>。</dd> <dt class="w3-pale-green w3-card-4">abstractmethod unregister(fileobj)</dt> <dd>注销对一个文件对象的选择，移除对它的监视。在文件对象被关闭之前应当先将其注销。</dd> <dd><code>fileobj</code>必须是之前已注册的文件对象。</dd> <dd>这将返回已关联的 <code>SelectorKey</code> 实例，或者如果 <code>fileobj</code> 未注册则会引发 <code>KeyError</code>。 如果 <code>fileobj</code> 无效（例如它没有 <code>fileobj()</code> 方法或其 <code>fileobj()</code> 方法返回无效值），则返回 <code>ValueError</code></dd>  <dt class="w3-pale-green w3-card-4">modify(fileobj, events, data=None)(fileobj)</dt> <dd>更改已注册文件对象所监视的事件或所附带的数据。</dd> <dd>这等价于 <code>BaseSelector.unregister(fileobj)()</code> 加 <code>BaseSelector.register(fileobj, events, data)()</code>，区别在于它可以被更高效地实现。</dd> <dd>这将返回一个新的 <code>SelectorKey</code> 实例，或在出现无效事件掩码或文件描述符时引发 <code>ValueError</code>，或在文件对象未被注册时引发 <code>KeyError</code>。</dd> <dt class="w3-pale-green w3-card-4">abstractmethod select(timeout=None)</dt> <dd>等待直到有已注册的文件对象就绪，或是超过时限。</dd> <dd>如果 <code>timeout &gt; 0</code>，这指定以秒数表示的最大等待时间。如果 <code>timeout &lt;= 0</code>，调用将不会阻塞，并将报告当前就绪的文件对象。如果 <code>timeout</code> 为 <code>None</code>，调用将阻塞直到某个被监视的文件对象就绪。</dd> <dd>返回由 <code>(key, events)</code> 元组构成的列表，每项各表示一个就绪的文件对象。</dd> <dd><code>key</code> 是对应于就绪文件对象的 <code>SelectorKey</code> 实例。<code>events</code> 是在此文件对象上等待的事件位掩码。</dd> <dd class="w3-card-4 w3-light-grey w3-padding"><span class="w3-text-blue">注解</span>：如果当前进程收到一个信号（<code>signal</code>），此方法可在任何文件对象就绪之前或超出时限时返回：在此情况下，将返回一个空列表。</dd><dd> </dd><dd>在 3.5 版更改: 现在当被某个信号中断时，如果信号处理程序没有引发异常，选择器会用重新计算的超时值进行重试（理由请查看 <a href="https://www.python.org/dev/peps/pep-0475">PEP 475</a> ），而不是在超时之前返回空的事件列表。</dd> <dt class="w3-pale-green w3-card-4">close()</dt> <dd>关闭选择器（selector）。</dd> <dd>必须调用这个方法以确保下层资源会被释放。选择器被关闭后将不可再使用。</dd> <dt class="w3-pale-green w3-card-4">get_key(fileobj)</dt> <dd>返回关联到某个已注册文件对象的键。</dd> <dd>此方法将返回关联到文件对象的 <code>SelectorKey</code> 实例，或在文件对象未注册时引发 <code>KeyError</code>。</dd> <dt class="w3-pale-green w3-card-4">abstractmethod get_map()</dt> <dd>返回从文件对象到选择器键的映射。</dd> <dd>返回一个将已注册文件对象映射到与其相关联的<code>SelectorKey</code> 实例的 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Mapping">Mapping</a> 实例。</dd></dl><h2 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h2><p>下面是一个简单的<code>echo</code>服务器实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> selectors<span class="token keyword">import</span> socket<span class="token comment"># 生成一个 select 对象</span>sel <span class="token operator">=</span> selectors<span class="token punctuation">.</span>DefaultSelector<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">:</span>    conn<span class="token punctuation">,</span> addr <span class="token operator">=</span> sock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># Should be ready</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'accepted'</span><span class="token punctuation">,</span> conn<span class="token punctuation">,</span> <span class="token string">'from'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>    conn<span class="token punctuation">.</span>setblocking<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment"># 设定非阻塞</span>    <span class="token comment"># 新连接注册 read 回调函数</span>    sel<span class="token punctuation">.</span>register<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> selectors<span class="token punctuation">.</span>EVENT_READ<span class="token punctuation">,</span> read<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">read</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>  <span class="token comment"># Should be ready</span>    <span class="token keyword">if</span> data<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'echoing'</span><span class="token punctuation">,</span> <span class="token builtin">repr</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'to'</span><span class="token punctuation">,</span> conn<span class="token punctuation">)</span>        conn<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data<span class="token punctuation">)</span>  <span class="token comment"># Hope it won't block</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'closing'</span><span class="token punctuation">,</span> conn<span class="token punctuation">)</span>        sel<span class="token punctuation">.</span>unregister<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>        conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>sock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>sock<span class="token punctuation">.</span>setblocking<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 把刚生成的sock连接对象注册到select连接列表中，并交给accept函数处理</span>sel<span class="token punctuation">.</span>register<span class="token punctuation">(</span>sock<span class="token punctuation">,</span> selectors<span class="token punctuation">.</span>EVENT_READ<span class="token punctuation">,</span> accept<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    events <span class="token operator">=</span> sel<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 默认是阻塞，有活动连接就返回活动的连接列表</span>    <span class="token keyword">for</span> key<span class="token punctuation">,</span> mask <span class="token keyword">in</span> events<span class="token punctuation">:</span>        callback <span class="token operator">=</span> key<span class="token punctuation">.</span>data <span class="token comment"># 去调accept函数</span>        callback<span class="token punctuation">(</span>key<span class="token punctuation">.</span>fileobj<span class="token punctuation">,</span> mask<span class="token punctuation">)</span>  <span class="token comment"># key.fileobj就是readable中的一个socket连接对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://pymotw.com/3/selectors/">https://pymotw.com/3/selectors/</a></p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/asyncio/">asyncio</category>
      
      
      <comments>https://xinetzone.github.io/python/zh-CN/c7565b5b6ae3.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python 异步编程技巧</title>
      <link>https://xinetzone.github.io/python/zh-CN/59343b396510.html</link>
      <guid>https://xinetzone.github.io/python/zh-CN/59343b396510.html</guid>
      <pubDate>Thu, 22 Apr 2021 00:04:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;经验告诉我们永远不要面向用户的接口暴露 &lt;code&gt;Future&lt;/code&gt; 对象，同时建议使用&amp;nbsp;&lt;a href=&quot;https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio</description>
        
      
      
      
      <content:encoded><![CDATA[<p>经验告诉我们永远不要面向用户的接口暴露 <code>Future</code> 对象，同时建议使用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.create_future" title="asyncio.loop.create_future"><code>loop.create_future()</code></a>&nbsp;来创建 <code>Future</code> 对象。这种方法可以让 <code>Future</code> 对象使用其它的事件循环实现，它可以注入自己的优化实现。</p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/asyncio/">asyncio</category>
      
      
      <comments>https://xinetzone.github.io/python/zh-CN/59343b396510.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>并发执行任务</title>
      <link>https://xinetzone.github.io/post/zh-CN/99261320ee2d.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/99261320ee2d.html</guid>
      <pubDate>Wed, 21 Apr 2021 04:42:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;任务（&lt;code&gt;Task&lt;/code&gt;）是与事件循环进行交互的主要方式之一。任务包装协程并跟踪它们何时完成。任务是 &lt;code&gt;Future&lt;/code&gt; 的子类，因此其他协程可以等待它们，并且每个协程都有可以在任务完成后检索的结果。&lt;/p&gt;
&lt;h2 id=&quot;创建任务&quot;&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>任务（<code>Task</code>）是与事件循环进行交互的主要方式之一。任务包装协程并跟踪它们何时完成。任务是 <code>Future</code> 的子类，因此其他协程可以等待它们，并且每个协程都有可以在任务完成后检索的结果。</p><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>要启动任务，请使用 <code>create_task()</code> 创建一个 <code>Task</code> 实例。只要循环正在运行且协程不返回，结果任务将作为事件循环管理的并发操作的一部分运行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_create_task.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">task_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in task_func'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'the result'</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'creating task'</span><span class="token punctuation">)</span>    task <span class="token operator">=</span> loop<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>task_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'waiting for </span><span class="token interpolation"><span class="token punctuation">{</span>task<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    return_value <span class="token operator">=</span> <span class="token keyword">await</span> task    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'task completed </span><span class="token interpolation"><span class="token punctuation">{</span>task<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'return value: </span><span class="token interpolation"><span class="token punctuation">{</span>return_value<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本示例在 <code>main()</code> 函数退出之前等待任务返回结果。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_create_task.pycreating taskwaiting <span class="token keyword">for</span> <span class="token operator">&lt;</span>Task pending <span class="token assign-left variable">coro</span><span class="token operator">=</span><span class="token operator">&lt;</span>task_func<span class="token punctuation">(</span><span class="token punctuation">)</span> running atasyncio_create_task.py:1<span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span><span class="token keyword">in</span> task_functask completed <span class="token operator">&lt;</span>Task finished <span class="token assign-left variable">coro</span><span class="token operator">=</span><span class="token operator">&lt;</span>task_func<span class="token punctuation">(</span><span class="token punctuation">)</span> done, defined atasyncio_create_task.py:1<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> <span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token string">'the result'</span><span class="token operator">&gt;</span><span class="token builtin class-name">return</span> value: <span class="token string">'the result'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h2><p>通过保留从 <code>create_task()</code> 返回的 <code>Task</code> 对象，可以在任务完成之前取消其操作。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_cancel_task.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">task_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in task_func'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'the result'</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'creating task'</span><span class="token punctuation">)</span>    task <span class="token operator">=</span> loop<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>task_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'canceling task'</span><span class="token punctuation">)</span>    task<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'canceled task </span><span class="token interpolation"><span class="token punctuation">{</span>task<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">await</span> task    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>CancelledError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'caught error from canceled task'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'task result: </span><span class="token interpolation"><span class="token punctuation">{</span>task<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本示例在启动事件循环之前创建并取消任务。结果是来自 <code>run_until_complete()</code> 的 <code>CancelledError</code> 异常。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_cancel_task.pycreating taskcanceling taskcanceled task <span class="token operator">&lt;</span>Task cancelling <span class="token assign-left variable">coro</span><span class="token operator">=</span><span class="token operator">&lt;</span>task_func<span class="token punctuation">(</span><span class="token punctuation">)</span> running atasyncio_cancel_task.py:1<span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span>caught error from canceled task<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果任务在等待另一个并发操作时被取消，则通过在任务等待时引发 <code>CancelledError</code> 异常来通知该任务已取消。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_cancel_task2.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">task_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in task_func, sleeping'</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>CancelledError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'task_func was canceled'</span><span class="token punctuation">)</span>        <span class="token keyword">raise</span>    <span class="token keyword">return</span> <span class="token string">'the result'</span><span class="token keyword">def</span> <span class="token function">task_canceller</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in task_canceller'</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'canceled the task'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'creating task'</span><span class="token punctuation">)</span>    task <span class="token operator">=</span> loop<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>task_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>task_canceller<span class="token punctuation">,</span> task<span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">await</span> task    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>CancelledError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'main() also sees task as canceled'</span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如有必要，捕获异常可提供清理已完成工作的机会。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_cancel_task2.pycreating task<span class="token keyword">in</span> task_func, sleeping<span class="token keyword">in</span> task_cancellercanceled the tasktask_func was canceledmain<span class="token punctuation">(</span><span class="token punctuation">)</span> also sees task as canceled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从协程中创建任务"><a href="#从协程中创建任务" class="headerlink" title="从协程中创建任务"></a>从协程中创建任务</h2><p><code>ensure_future()</code> 函数返回与协程的执行相关的 <code>Task</code>。然后可以将该 <code>Task</code> 实例传递给其他代码，后者可以在不知道原始协程如何构造或调用的情况下等待它。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_ensure_future.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">wrapped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'wrapped'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'result'</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'inner: starting'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'inner: waiting for </span><span class="token interpolation"><span class="token punctuation">{</span>task<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    result <span class="token operator">=</span> <span class="token keyword">await</span> task    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'inner: task returned </span><span class="token interpolation"><span class="token punctuation">{</span>result<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">starter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'starter: creating task'</span><span class="token punctuation">)</span>    task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>wrapped<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'starter: waiting for inner'</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> inner<span class="token punctuation">(</span>task<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'starter: inner returned'</span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'entering event loop'</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>starter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，直到有某种使用 <code>await</code> 执行的协程才启动给 <code>ensure_future()</code> 的协程。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_ensure_future.pyentering event loopstarter: creating taskstarter: waiting <span class="token keyword">for</span> innerinner: startinginner: waiting <span class="token keyword">for</span> <span class="token operator">&lt;</span>Task pending <span class="token assign-left variable">coro</span><span class="token operator">=</span><span class="token operator">&lt;</span>wrapped<span class="token punctuation">(</span><span class="token punctuation">)</span> running atasyncio_ensure_future.py:1<span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span>wrappedinner: task returned <span class="token string">'result'</span>starter: inner returned<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/asyncio/">asyncio</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/99261320ee2d.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Future 以异步方式生成数据</title>
      <link>https://xinetzone.github.io/post/zh-CN/3cef5935d457.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/3cef5935d457.html</guid>
      <pubDate>Wed, 21 Apr 2021 03:21:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 对象用来链接 &lt;strong&gt;底层回调式代码&lt;/strong&gt; 和高层异步/等待式代码。&lt;/p&gt;
&lt;h2 id=&quot;Future-对象&quot;&gt;&lt;a href=&quot;#Future-对象&quot; class=&quot;headerlink&quot; title=&quot;Fu</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>Future</code> 对象用来链接 <strong>底层回调式代码</strong> 和高层异步/等待式代码。</p><h2 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h2><p>class <code>asyncio.Future(*, loop=None)</code>：一个 <code>Future</code> 代表一个异步运算的最终结果。线程不安全。</p><p><code>Future</code> 是一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-awaitable">awaitable</a>&nbsp;对象。协程可以等待 <code>Future</code> 对象直到它们有结果或异常集合或被取消。</p><p>通常 <code>Future</code> 用于支持底层回调式代码(例如在协议实现中使用 <code>asyncio</code>&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-protocol.html#asyncio-transports-protocols">transports</a>) 与高层异步/等待式代码交互。</p><p>经验告诉我们永远不要面向用户的接口暴露 <code>Future</code> 对象，同时建议使用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.create_future" title="asyncio.loop.create_future"><code>loop.create_future()</code></a>&nbsp;来创建 <code>Future</code> 对象。这种方法可以让 <code>Future</code> 对象使用其它的事件循环实现，它可以注入自己的优化实现。</p><h3 id="set-result-result"><a href="#set-result-result" class="headerlink" title="set_result(result)"></a><code>set_result(result)</code></h3><p>将 <code>Future</code> 标记为&nbsp;<em>完成</em>&nbsp;并设置结果。</p><p>如果 <code>Future</code> 已经&nbsp;<em>完成</em>&nbsp;则抛出一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>&nbsp;错误。</p><h3 id="result"><a href="#result" class="headerlink" title="result()"></a><code>result()</code></h3><p>返回 <code>Future</code> 的结果。</p><p>如果 <code>Future</code> 状态为&nbsp;<em>完成</em>&nbsp;，并由&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.set_result" title="asyncio.Future.set_result"><code>set_result()</code></a>&nbsp;方法设置一个结果，则返回这个结果。</p><p>如果 <code>Future</code> 状态为&nbsp;<em>完成</em>&nbsp;，并由&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.set_exception" title="asyncio.Future.set_exception"><code>set_exception()</code></a>&nbsp;方法设置一个异常，那么这个方法会引发异常。</p><p>如果 <code>Future</code> 已&nbsp;<em>取消</em>，方法会引发一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code>CancelledError</code></a>&nbsp;异常。</p><p>如果 <code>Future</code> 的结果还不可用，此方法会引发一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>&nbsp;异常。</p><h3 id="set-exception-exception"><a href="#set-exception-exception" class="headerlink" title="set_exception(exception)"></a><code>set_exception(exception)</code></h3><p>将 F<code>uture</code> 标记为&nbsp;<em>完成</em>&nbsp;并设置一个异常。</p><p>如果 <code>Future</code> 已经&nbsp;<em>完成</em>&nbsp;则抛出一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>&nbsp;错误。</p><h3 id="done"><a href="#done" class="headerlink" title="done()"></a><code>done()</code></h3><p>如果 <code>Future</code> 为已&nbsp;<em>完成</em>&nbsp;则返回&nbsp;<code>True</code>。</p><p>如果 <code>Future</code> 为&nbsp;<em>取消</em>&nbsp;或调用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.set_result" title="asyncio.Future.set_result"><code>set_result()</code></a>&nbsp;设置了结果或调用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.set_exception" title="asyncio.Future.set_exception"><code>set_exception()</code></a>&nbsp;设置了异常，那么它就是&nbsp;<em>完成</em>。</p><h3 id="cancelled"><a href="#cancelled" class="headerlink" title="cancelled()"></a><code>cancelled()</code></h3><p>如果 <code>Future</code> 已 取消 则返回 <code>True</code>。</p><p>这个方法通常在设置结果或异常前用来检查 <code>Future</code> 是否已 <em>取消</em>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> <span class="token keyword">not</span> fut<span class="token punctuation">.</span>cancelled<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    fut<span class="token punctuation">.</span>set_result<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="add-done-callback-callback-context-None"><a href="#add-done-callback-callback-context-None" class="headerlink" title="add_done_callback(callback, *, context=None)"></a><code>add_done_callback(callback, *, context=None)</code></h3><p>添加一个在 <code>Future</code>&nbsp;<em>完成</em>&nbsp;时运行的回调函数。</p><p>调用&nbsp;<em><code>callback</code></em>&nbsp;时，<code>Future</code> 对象是它的唯一参数。</p><p>调用这个方法时 <code>Future</code> 已经&nbsp;<em>完成</em>&nbsp;, 回调函数已被&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code>loop.call_soon()</code></a>&nbsp;调度。</p><p>可选键值类的参数&nbsp;<em><code>context</code></em>&nbsp;允许&nbsp;<em><code>callback</code></em>&nbsp;运行在一个指定的自定义&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/contextvars.html#contextvars.Context" title="contextvars.Context"><code>contextvars.Context</code></a>&nbsp;对象中。如果没有提供&nbsp;<em><code>context</code></em>&nbsp;，则使用当前上下文。</p><p>可以用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a>&nbsp;给回调函数传递参数，例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Call 'print("Future:", fut)' when "fut" is done.</span>fut<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>    functools<span class="token punctuation">.</span>partial<span class="token punctuation">(</span><span class="token keyword">print</span><span class="token punctuation">,</span> <span class="token string">"Future:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="remove-done-callback-callback"><a href="#remove-done-callback-callback" class="headerlink" title="remove_done_callback(callback)"></a><code>remove_done_callback(callback)</code></h3><p>从回调列表中移除 <code>callback</code>。</p><p>返回被移除的回调函数的数量，通常为 1，除非一个回调函数被添加多次。</p><h3 id="cancel-msg-None"><a href="#cancel-msg-None" class="headerlink" title="cancel(msg=None)"></a><code>cancel(msg=None)</code></h3><p>取消 <code>Future</code> 并调度回调函数。</p><p>如果 <code>Future</code> 已经 <em>完成</em> 或 <em>取消</em>，返回 <code>False</code>。否则将 <code>Future</code> 状态改为 <em>取消</em> 并在调度回调函数后返回 <code>True</code>。</p><h3 id="exception"><a href="#exception" class="headerlink" title="exception()"></a><code>exception()</code></h3><p>返回 <code>Future</code> 已设置的异常。</p><p>只有 <code>Future</code> 在&nbsp;<em>完成</em>&nbsp;时才返回异常（或者&nbsp;<code>None</code>&nbsp;，如果没有设置异常）。</p><p>如果 <code>Future</code> 已&nbsp;<em>取消</em>，方法会引发一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code>CancelledError</code></a>&nbsp;异常。</p><p>如果 <code>Future</code> 还没&nbsp;<em>完成</em>&nbsp;，这个方法会引发一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>&nbsp;异常。</p><h3 id="get-loop"><a href="#get-loop" class="headerlink" title="get_loop()"></a><code>get_loop()</code></h3><p>返回 <code>Future</code> 对象已绑定的事件循环。</p><h2 id="Future-函数"><a href="#Future-函数" class="headerlink" title="Future 函数"></a>Future 函数</h2><h3 id="asyncio-isfuture-obj"><a href="#asyncio-isfuture-obj" class="headerlink" title="asyncio.isfuture(obj)"></a><code>asyncio.isfuture(obj)</code></h3><p>如果 <code>obj</code> 为下面任意对象，返回 <code>True</code>：</p><ul><li>一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code>asyncio.Future</code></a>&nbsp;类的实例，</li><li>一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.Task" title="asyncio.Task"><code>asyncio.Task</code></a>&nbsp;类的实例，</li><li>带有&nbsp;<code>_asyncio_future_blocking</code>&nbsp;属性的类似 <code>Future</code> 的对象。</li></ul><h3 id="asyncio-ensure-future-obj-loop-None"><a href="#asyncio-ensure-future-obj-loop-None" class="headerlink" title="asyncio.ensure_future(obj, *, loop=None)"></a><code>asyncio.ensure_future(obj, *, loop=None)</code></h3><p>返回：</p><ul><li><p><em><code>obj</code></em>&nbsp;参数会是保持原样，如果&nbsp;<em><code>obj</code></em>&nbsp;是&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code>Future</code></a>、&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.Task" title="asyncio.Task"><code>Task</code></a>&nbsp;或 类似 Future 的对象(&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.isfuture" title="asyncio.isfuture"><code>isfuture()</code></a>&nbsp;用于测试。)</p></li><li><p>封装了&nbsp;<em><code>obj</code></em>&nbsp;的&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.Task" title="asyncio.Task"><code>Task</code></a>&nbsp;对象，如果&nbsp;<em><code>obj</code></em>&nbsp;是一个协程 (使用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.iscoroutine" title="asyncio.iscoroutine"><code>iscoroutine()</code></a>&nbsp;进行检测)；在此情况下该协程将通过&nbsp;<code>ensure_future()</code>&nbsp;加入执行计划。</p></li><li><p>等待&nbsp;<em><code>obj</code></em>&nbsp;的&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.Task" title="asyncio.Task"><code>Task</code></a>&nbsp;对象，如果&nbsp;<em><code>obj</code></em>&nbsp;是一个可等待对象(&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/inspect.html#inspect.isawaitable" title="inspect.isawaitable"><code>inspect.isawaitable()</code></a>&nbsp;用于测试)</p></li></ul><p>如果 <code>obj</code> 不是上述对象会引发一个 <code>TypeError</code> 异常。</p><h3 id="asyncio-wrap-future-future-loop-None"><a href="#asyncio-wrap-future-future-loop-None" class="headerlink" title="asyncio.wrap_future(future, *, loop=None)"></a><code>asyncio.wrap_future(future, *, loop=None)</code></h3><p>将一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/concurrent.futures.html#concurrent.futures.Future" title="concurrent.futures.Future"><code>concurrent.futures.Future</code></a>&nbsp;对象封装到&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code>asyncio.Future</code></a>&nbsp;对象中。</p><h2 id="Waiting-for-a-Future"><a href="#Waiting-for-a-Future" class="headerlink" title="Waiting for a Future"></a>Waiting for a Future</h2><p><code>Future</code> 的行为就像协程，因此，任何用于等待协程的有用技术也可以用来等待 <code>future</code> 被标记为完成。本示例将 <code>future</code> 传递给事件循环的 <code>run_until_complete()</code> 方法。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_future_event_loop.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">def</span> <span class="token function">mark_done</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'setting future result to </span><span class="token interpolation"><span class="token punctuation">{</span>result<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    future<span class="token punctuation">.</span>set_result<span class="token punctuation">(</span>result<span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    all_done <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Future<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'scheduling mark_done'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>mark_done<span class="token punctuation">,</span> all_done<span class="token punctuation">,</span> <span class="token string">'the result'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'entering event loop'</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>all_done<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'returned result: </span><span class="token interpolation"><span class="token punctuation">{</span>result<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'closing event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'future result: </span><span class="token interpolation"><span class="token punctuation">{</span>all_done<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当调用 <code>set_result()</code> 时，<code>Future</code> 的状态更改为完成，并且 <code>Future</code> 实例保留提供给该方法的结果供以后检索。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_future_event_loop.pyscheduling mark_doneentering event loopsetting future result to <span class="token string">'the result'</span>returned result: <span class="token string">'the result'</span>closing event loopfuture result: <span class="token string">'the result'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Future</code> 也可以与 <code>await</code> 关键字一起使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_future_await.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">def</span> <span class="token function">mark_done</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'setting future result to </span><span class="token interpolation"><span class="token punctuation">{</span>result<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    future<span class="token punctuation">.</span>set_result<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    all_done <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Future<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'scheduling mark_done'</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>mark_done<span class="token punctuation">,</span> all_done<span class="token punctuation">,</span> <span class="token string">'the result'</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> <span class="token keyword">await</span> all_done    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'returned result: </span><span class="token interpolation"><span class="token punctuation">{</span>result<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Future</code> 的结果是由 <code>await</code> 返回的，因此通常可以在常规协程和 <code>Future</code> 实例中使用相同的代码。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_future_await.pyscheduling mark_donesetting future result to <span class="token string">'the result'</span>returned result: <span class="token string">'the result'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Future-Callbacks"><a href="#Future-Callbacks" class="headerlink" title="Future Callbacks"></a>Future Callbacks</h2><p>除了像协程一样工作，<code>Future</code> 还可以在完成时调用回调。回调按注册顺序调用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_future_callback.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">callback</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>n<span class="token punctuation">}</span></span><span class="token string">: future done: </span><span class="token interpolation"><span class="token punctuation">{</span>future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">register_callbacks</span><span class="token punctuation">(</span>all_done<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'registering callbacks on future'</span><span class="token punctuation">)</span>    all_done<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>functools<span class="token punctuation">.</span>partial<span class="token punctuation">(</span>callback<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    all_done<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>functools<span class="token punctuation">.</span>partial<span class="token punctuation">(</span>callback<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>all_done<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">await</span> register_callbacks<span class="token punctuation">(</span>all_done<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'setting result of future'</span><span class="token punctuation">)</span>    all_done<span class="token punctuation">.</span>set_result<span class="token punctuation">(</span><span class="token string">'the result'</span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    all_done <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Future<span class="token punctuation">(</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>all_done<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回调应包含一个参数，即 <code>Future</code> 实例。要将其他参数传递给回调，请使用 <code>functools.partial()</code> 创建包装器。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_future_callback.pyregistering callbacks on futuresetting result of future<span class="token number">1</span>: future done: <span class="token string">'the result'</span><span class="token number">2</span>: future done: <span class="token string">'the result'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用事件循环创建-Future"><a href="#使用事件循环创建-Future" class="headerlink" title="使用事件循环创建 Future"></a>使用事件循环创建 Future</h2><p>这个例子创建一个 <code>Future</code> 对象，创建和调度一个异步任务去设置 <code>Future</code> 结果，然后等待其结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">set_after</span><span class="token punctuation">(</span>fut<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Sleep for *delay* seconds.</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>    <span class="token comment"># Set *value* as a result of *fut* Future.</span>    fut<span class="token punctuation">.</span>set_result<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Get the current event loop.</span>    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Create a new Future object.</span>    fut <span class="token operator">=</span> loop<span class="token punctuation">.</span>create_future<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Run "set_after()" coroutine in a parallel Task.</span>    <span class="token comment"># We are using the low-level "loop.create_task()" API here because</span>    <span class="token comment"># we already have a reference to the event loop at hand.</span>    <span class="token comment"># Otherwise we could have just used "asyncio.create_task()".</span>    loop<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>        set_after<span class="token punctuation">(</span>fut<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'... world'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello ...'</span><span class="token punctuation">)</span>    <span class="token comment"># Wait until *fut* has a result (1 second) and print it.</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token keyword">await</span> fut<span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重要</strong>：该 <code>Future</code> 对象是为了模仿 <code>concurrent.futures.Future</code> 类。主要差异包含：</p><ul><li><p>与 asyncio 的 Future 不同，<a href="https://docs.python.org/zh-cn/3.10/library/concurrent.futures.html#concurrent.futures.Future" title="concurrent.futures.Future"><code>concurrent.futures.Future</code></a>&nbsp;实例不是可等待对象。</p></li><li><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.result" title="asyncio.Future.result"><code>asyncio.Future.result()</code></a>&nbsp;和&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.exception" title="asyncio.Future.exception"><code>asyncio.Future.exception()</code></a>&nbsp;不接受&nbsp;<em>timeout</em>&nbsp;参数。</p></li><li><p>Future 没有&nbsp;<em>完成</em>&nbsp;时&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.result" title="asyncio.Future.result"><code>asyncio.Future.result()</code></a>&nbsp;和&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.exception" title="asyncio.Future.exception"><code>asyncio.Future.exception()</code></a>&nbsp;抛出一个&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code>InvalidStateError</code></a>&nbsp;异常。</p></li><li><p>使用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code>asyncio.Future.add_done_callback()</code></a>&nbsp;注册的回调函数不会立即调用，而是被&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code>loop.call_soon()</code></a>&nbsp;调度。</p></li><li><p><code>asyncio.Future</code> 不能兼容&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/concurrent.futures.html#concurrent.futures.wait" title="concurrent.futures.wait"><code>concurrent.futures.wait()</code></a>&nbsp;和&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/concurrent.futures.html#concurrent.futures.as_completed" title="concurrent.futures.as_completed"><code>concurrent.futures.as_completed()</code></a>&nbsp;函数。</p></li><li><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future.cancel" title="asyncio.Future.cancel"><code>asyncio.Future.cancel()</code></a>&nbsp;接受一个可选的&nbsp;<code>msg</code>&nbsp;参数，但&nbsp;<code>concurrent.futures.cancel()</code>&nbsp;无此参数。</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/asyncio-Future/">asyncio.Future</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/3cef5935d457.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Scheduling Calls 设定定时器</title>
      <link>https://xinetzone.github.io/post/zh-CN/c30844b50b8e.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/c30844b50b8e.html</guid>
      <pubDate>Wed, 21 Apr 2021 02:11:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;除了管理协程和 I/O 回调外，&lt;code&gt;asyncio&lt;/code&gt; 事件循环还可以根据循环中保留的计时器值来调度对常规函数的调用。&lt;/p&gt;
&lt;h2 id=&quot;Scheduling-a-Callback-“Soon”&quot;&gt;&lt;a href=&quot;#Scheduling-a-Cal</description>
        
      
      
      
      <content:encoded><![CDATA[<p>除了管理协程和 I/O 回调外，<code>asyncio</code> 事件循环还可以根据循环中保留的计时器值来调度对常规函数的调用。</p><h2 id="Scheduling-a-Callback-“Soon”"><a href="#Scheduling-a-Callback-“Soon”" class="headerlink" title="Scheduling a Callback “Soon”"></a>Scheduling a Callback “Soon”</h2><p>如果回调的时间无关紧要，则可以使用 <code>call_soon()</code> 为循环的下一次迭代安排调用。调用该函数后，该函数之后的所有其他位置参数都将传递给该回调。要将关键字参数传递给回调，请使用 <a href="https://pymotw.com/3/functools/index.html#module-functools">functools</a> 模块中的 <code>partial()</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_call_soon.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">callback</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> kwarg<span class="token operator">=</span><span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'callback invoked with </span><span class="token interpolation"><span class="token punctuation">{</span>arg<span class="token punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token punctuation">{</span>kwarg<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'registering callbacks'</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    wrapped <span class="token operator">=</span> functools<span class="token punctuation">.</span>partial<span class="token punctuation">(</span>callback<span class="token punctuation">,</span> kwarg<span class="token operator">=</span><span class="token string">'not default'</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>wrapped<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'entering event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'closing event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回调按调度的顺序被调用。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_call_soon.pyentering event loopregistering callbackscallback invoked with <span class="token number">1</span> and defaultcallback invoked with <span class="token number">2</span> and not defaultclosing event loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注解：大多数&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code>asyncio</code></a>&nbsp;的调度函数不让传递关键字参数。为此，请使用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a>&nbsp;：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># will schedule "print("Hello", flush=True)"</span>loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>    functools<span class="token punctuation">.</span>partial<span class="token punctuation">(</span><span class="token keyword">print</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> flush<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>partial</code> 对象通常比使用 <code>lambda</code> 更方便，<code>asyncio</code> 在调试和错误消息中能更好的呈现 <code>partial</code> 对象。</p><p>更加友好的写法是：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_call_soon.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">callback</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> kwarg<span class="token operator">=</span><span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'callback invoked with </span><span class="token interpolation"><span class="token punctuation">{</span>arg<span class="token punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token punctuation">{</span>kwarg<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">call_soon</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'registering callbacks'</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    wrapped <span class="token operator">=</span> functools<span class="token punctuation">.</span>partial<span class="token punctuation">(</span>callback<span class="token punctuation">,</span> kwarg<span class="token operator">=</span><span class="token string">'not default'</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>wrapped<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'entering event loop'</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> call_soon<span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'closing event loop'</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安排回调"><a href="#安排回调" class="headerlink" title="安排回调"></a>安排回调</h3><ol><li><code>loop.call_soon(callback, *args, context=None)</code> 安排 <code>callback</code> 在事件循环的下一次迭代时附带 <code>args</code> 参数被调用。回调按其注册顺序被调用。每个回调仅被调用一次。可选的仅关键字型参数 <code>context</code> 允许为要运行的 <code>callback</code> 指定一个自定义 <code>contextvars.Context</code>。如果没有提供 <code>context</code>，则使用当前上下文。返回一个能用来取消回调的 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.Handle">asyncio.Handle</a> 实例。这个方法不是线程安全的。</li><li><code>loop.call_soon_threadsafe(callback, *args, context=None)</code> 是 <code>call_soon()</code> 的线程安全变体。必须被用于安排 来自其他线程 的回调。查看 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-dev.html#asyncio-multithreading">并发和多线程</a> 章节的文档。</li></ol><h2 id="调度延迟回调"><a href="#调度延迟回调" class="headerlink" title="调度延迟回调"></a>调度延迟回调</h2><p>事件循环提供安排调度函数在将来某个时刻调用的机制。事件循环使用单调时钟来跟踪时间。<code>loop.call_later(delay, callback, *args, context=None)</code> 安排 <code>callback</code> 在给定的 <code>delay</code> 秒（可以是 int 或者 float）后被调用。返回一个 asyncio.<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.TimerHandle">TimerHandle</a> 实例，该实例能用于取消回调。</p><p><code>callback</code> 只被调用一次。如果两个回调被安排在同样的时间点，执行顺序未限定。可选的位置参数&nbsp;<em><code>args</code></em>&nbsp;在被调用的时候传递给&nbsp;<em><code>callback</code></em>&nbsp;。如果你想把关键字参数传递给&nbsp;<em><code>callback</code></em>&nbsp;，请使用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a>&nbsp;。</p><p>可选的仅关键字型参数&nbsp;<em>context</em>&nbsp;允许为要运行的&nbsp;<em>callback</em>&nbsp;指定一个自定义&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/contextvars.html#contextvars.Context" title="contextvars.Context"><code>contextvars.Context</code></a>。如果没有提供&nbsp;<em><code>context</code></em>&nbsp;，则使用当前上下文。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_call_later.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">def</span> <span class="token function">callback</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'callback </span><span class="token interpolation"><span class="token punctuation">{</span>n<span class="token punctuation">}</span></span><span class="token string"> invoked'</span></span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'registering callbacks'</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_later<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_later<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.4</span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'entering event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'closing event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此示例中，使用不同的参数将相同的回调函数调度了几次不同的时间。使用 <code>call_soon()</code> 的最终实例导致在任何定时实例之前使用参数 3 调用回调，这表明“soon”通常意味着最小的延迟。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">$ python3 asyncio_call_later<span class="token punctuation">.</span>pyentering event loopregistering callbackscallback <span class="token number">3</span> invokedcallback <span class="token number">2</span> invokedcallback <span class="token number">1</span> invokedclosing event loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安排特定时间的回调"><a href="#安排特定时间的回调" class="headerlink" title="安排特定时间的回调"></a>安排特定时间的回调</h2><p>也可以安排在特定时间进行回调。该 <code>loop</code> 使用单调时钟（monotonic clock）而不是挂钟时间（wall-clock tim），以确保“now”的值永不回归。要为计划的回调选择时间，必须使用 <code>loop</code> 的 <code>time()</code> 方法从该时钟的内部状态开始。</p><p><code>loop.call_at(when, callback, *args, context=None)</code> 安排 <code>callback</code> 在给定的绝对时间戳 <code>when</code> (<code>int</code> 或 <code>float</code>) 被调用，使用与 <code>loop.time()</code> 同样的时间参考。这个函数的行为与&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.call_later" title="asyncio.loop.call_later"><code>call_later()</code></a>&nbsp;相同。返回一个 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.TimerHandle" title="asyncio.TimerHandle"><code>asyncio.TimerHandle</code></a>&nbsp;实例，该实例能用于取消回调。</p><p><code>loop.time()</code> 根据时间循环内部的单调时钟，返回当前时间为一个 <code>float</code> 值。参见 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.sleep">asyncio.sleep()</a> 函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_call_at.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">callback</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'callback </span><span class="token interpolation"><span class="token punctuation">{</span>n<span class="token punctuation">}</span></span><span class="token string"> invoked at </span><span class="token interpolation"><span class="token punctuation">{</span>loop<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">:</span>    now <span class="token operator">=</span> loop<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'clock time: </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'loop  time: </span><span class="token interpolation"><span class="token punctuation">{</span>now<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'registering callbacks'</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_at<span class="token punctuation">(</span>now <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> loop<span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_at<span class="token punctuation">(</span>now <span class="token operator">+</span> <span class="token number">0.1</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> loop<span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> loop<span class="token punctuation">)</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'entering event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'closing event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，对应的 <code>loop</code> 的时间与 <code>time.time()</code> 返回的值不匹配。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_call_at.pyentering event loopclock time: <span class="token number">1618973483.6534503</span>loop  time: <span class="token number">3016024.109</span>registering callbackscallback <span class="token number">3</span> invoked at <span class="token number">3016024.109</span>callback <span class="token number">2</span> invoked at <span class="token number">3016024.218</span>callback <span class="token number">1</span> invoked at <span class="token number">3016024.312</span>closing event loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/asyncio/">asyncio</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/c30844b50b8e.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用协程书写多任务合作代码</title>
      <link>https://xinetzone.github.io/post/zh-CN/779e0dcc29b0.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/779e0dcc29b0.html</guid>
      <pubDate>Wed, 21 Apr 2021 00:36:33 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;协程（Coroutine）是为并发操作而设计的语言构造。协程函数在被调用时会创建一个协程对象，然后调用者可以使用协程的 &lt;code&gt;send()&lt;/code&gt; 方法运行该函数的代码。一个协程可以将 &lt;code&gt;await&lt;/code&gt; 关键字与另一个协程一起暂停执行。暂停时</description>
        
      
      
      
      <content:encoded><![CDATA[<p>协程（Coroutine）是为并发操作而设计的语言构造。协程函数在被调用时会创建一个协程对象，然后调用者可以使用协程的 <code>send()</code> 方法运行该函数的代码。一个协程可以将 <code>await</code> 关键字与另一个协程一起暂停执行。暂停时，协程的状态得以维持，使其在下次唤醒时可以从中断的位置恢复。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环是每个 <code>asyncio</code> 应用的核心。事件循环会运行异步任务和回调，执行网络 IO 操作，以及运行子进程。</p><p>应用开发者通常应当使用高层级的 <code>asyncio</code> 函数，例如 <code>asyncio.run()</code>，应当很少有必要引用<code>loop</code>对象或调用其方法。</p><p>以下低层级函数可被用于获取、设置或创建事件循环：</p><ol><li><code>asyncio.get_running_loop()</code> 返回当前 OS 线程中正在运行的事件循环。如果没有正在运行的事件循环则会引发 <code>RuntimeError</code>。此函数只能由协程或回调来调用。</li><li><code>asyncio.get_event_loop()</code> 获取当前事件循环。如果当前 OS 线程没有设置当前事件循环，该 OS 线程为主线程，并且 <code>set_event_loop()</code> 还没有被调用，则 <code>asyncio</code> 将创建一个新的事件循环并将其设为当前事件循环。由于此函数具有相当复杂的行为（特别是在使用了自定义事件循环策略的时候），更推荐在协程和回调中使用 <code>get_running_loop()</code> 函数而非 <code>get_event_loop()</code>。<span class="w3-pale-green">应该考虑使用 <code>asyncio.run()</code> 函数而非使用低层级函数来手动创建和关闭事件循环。</span></li><li><code>asyncio.set_event_loop(loop)</code> 将 <code>loop</code> 设置为当前 OS 线程的当前事件循环。</li><li><code>asyncio.new_event_loop()</code> 创建一个新的事件循环。</li></ol><p>请注意&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.get_event_loop" title="asyncio.get_event_loop"><code>get_event_loop()</code></a>，<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.set_event_loop" title="asyncio.set_event_loop"><code>set_event_loop()</code></a>&nbsp;以及&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.new_event_loop" title="asyncio.new_event_loop"><code>new_event_loop()</code></a>&nbsp;函数的行为可以通过&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-policy.html#asyncio-policies">设置自定义事件循环策略</a>&nbsp;来改变。</p><h2 id="启动协程"><a href="#启动协程" class="headerlink" title="启动协程"></a>启动协程</h2><p>有几种不同的方法可以使 <code>asyncio</code> 事件循环启动协程。最简单的方法是使用 <code>run_until_complete()</code>，将协程直接传递给它。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_coroutine.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in coroutine'</span><span class="token punctuation">)</span><span class="token comment"># 获取对事件循环的引用</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'starting coroutine'</span><span class="token punctuation">)</span>    coro <span class="token operator">=</span> coroutine<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'entering event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>coro<span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'closing event loop'</span><span class="token punctuation">)</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一步是获取对事件循环的引用。可以使用默认的循环类型，或者可以实例化特定的循环类。在此示例中，使用默认循环。<code>run_until_complete()</code> 方法使用协程对象启动循环，并在协程退出返回时停止循环。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python asyncio_coroutine.pystarting coroutineentering event loop<span class="token keyword">in</span> coroutineclosing event loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行和停止循环"><a href="#运行和停止循环" class="headerlink" title="运行和停止循环"></a>运行和停止循环</h3><ol><li><code>loop.run_until_complete(future)</code> 运行直到 future(<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio.Future">Future</a> 的实例) 被完成。如果参数是 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#coroutine">coroutine object</a>，将被隐式调度为 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.Task">asyncio.Task</a> 来运行。</li><li><code>loop.run_forever()</code> 运行事件循环直到 <code>stop()</code> 被调用。如果&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.stop" title="asyncio.loop.stop"><code>stop()</code></a>&nbsp;在调用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code>run_forever()</code></a>&nbsp;之前被调用，循环将轮询一次 I/O 选择器并设置超时为零，再运行所有已加入计划任务的回调来响应 I/O 事件（以及已加入计划任务的事件），然后退出。如果&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.stop" title="asyncio.loop.stop"><code>stop()</code></a>&nbsp;在&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code>run_forever()</code></a>&nbsp;运行期间被调用，循环将运行当前批次的回调然后退出。请注意在此情况下由回调加入计划任务的新回调将不会运行；它们将会在下次&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code>run_forever()</code></a>&nbsp;或&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code>run_until_complete()</code></a>&nbsp;被调用时运行。</li><li><code>loop.stop()</code> 停止事件循环。</li><li><code>loop.is_running()</code> 返回 <code>True</code> 如果事件循环当前正在运行。</li><li><code>loop.is_closed()</code>如果事件循环已经被关闭，返回 <code>True</code>。</li><li><code>loop.close()</code> 关闭事件循环。当这个函数被调用的时候，循环必须处于非运行状态。<code>pending</code> 状态的回调将被丢弃。此方法清除所有的队列并立即关闭执行器，不会等待执行器完成。这个方法是幂等的和不可逆的（idempotent and irreversible）。事件循环关闭后，不应调用其他方法。</li><li>coroutine <code>loop.shutdown_asyncgens()</code> 安排所有当前打开的&nbsp;<a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-generator">asynchronous generator</a>&nbsp;对象通过&nbsp;<a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#agen.aclose" title="agen.aclose"><code>aclose()</code></a>&nbsp;调用来关闭。在调用此方法后，如果有新的异步生成器被迭代事件循环将会发出警告。这应当被用来可靠地完成所有已加入计划任务的异步生成器。请注意当使用&nbsp;<a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.run" title="asyncio.run"><code>asyncio.run()</code></a>&nbsp;时不必调用此函数。</li></ol><p>示例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    loop<span class="token punctuation">.</span>run_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>loop<span class="token punctuation">.</span>shutdown_asyncgens<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="8"><li><code>coroutine loop.shutdown_default_executor()</code> 安排默认执行器的关闭并等待它合并 <code>ThreadPoolExecutor</code> 中的所有线程。在调用此方法后，如果在使用默认执行器期间调用了 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.run_in_executor">loop.run_in_executor()</a> 则将会引发 <code>RuntimeError</code>。请注意当使用 <code>asyncio.run()</code> 时不必调用此函数。</li></ol><h2 id="从协程返回值"><a href="#从协程返回值" class="headerlink" title="从协程返回值"></a>从协程返回值</h2><p>协程的返回值被传递回启动并等待它的代码。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_coroutine_return.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in coroutine'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'result'</span>event_loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    return_value <span class="token operator">=</span> event_loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>        coroutine<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'it returned: </span><span class="token interpolation"><span class="token punctuation">{</span>return_value<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    event_loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，<code>run_until_complete()</code> 还返回它正在等待的协程的结果。</p><p>更加简便的写法是：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_coroutine_return.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in coroutine'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'result'</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    return_value <span class="token operator">=</span> <span class="token keyword">await</span> coroutine<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'it returned: </span><span class="token interpolation"><span class="token punctuation">{</span>return_value<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python asyncio_coroutine_return.py<span class="token keyword">in</span> coroutineit returned: 'result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="协程链"><a href="#协程链" class="headerlink" title="协程链"></a>协程链</h2><p>一个协程可以启动另一个协程并等待结果。这使得将任务分解为可重用的部分变得更加容易。以下示例具有必须按顺序执行的两个阶段，但是可以与其他操作同时运行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># asyncio_coroutine_chain.py</span><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in outer'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'waiting for result1'</span><span class="token punctuation">)</span>    result1 <span class="token operator">=</span> <span class="token keyword">await</span> phase1<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'waiting for result2'</span><span class="token punctuation">)</span>    result2 <span class="token operator">=</span> <span class="token keyword">await</span> phase2<span class="token punctuation">(</span>result1<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">phase1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in phase1'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'result1'</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">phase2</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in phase2'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f'result2 derived from </span><span class="token interpolation"><span class="token punctuation">{</span>arg<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    return_value <span class="token operator">=</span> <span class="token keyword">await</span> outer<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'return value: </span><span class="token interpolation"><span class="token punctuation">{</span>return_value<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>await</code> 关键字而不是将新的协程添加到循环中，因为控制流已经在由循环管理的协程内部，因此不必告诉循环来管理新的协程。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 asyncio_coroutine_chain.py<span class="token keyword">in</span> outerwaiting <span class="token keyword">for</span> <span class="token for-or-select variable">result1</span><span class="token keyword">in</span> phase1waiting <span class="token keyword">for</span> <span class="token for-or-select variable">result2</span><span class="token keyword">in</span> phase2<span class="token builtin class-name">return</span> value: <span class="token punctuation">(</span><span class="token string">'result1'</span>, <span class="token string">'result2 derived from result1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/asyncio/">asyncio</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/779e0dcc29b0.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>contextvars 上下文变量</title>
      <link>https://xinetzone.github.io/post/zh-CN/c4a5cb4d78b1.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/c4a5cb4d78b1.html</guid>
      <pubDate>Tue, 20 Apr 2021 08:13:03 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.10/library/contextvars.html&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt; 提供了用于管理、存储和访问上下文相关状态的相关 API。&lt;code&gt;Cont</description>
        
      
      
      
      <content:encoded><![CDATA[<p><a href="https://docs.python.org/zh-cn/3.10/library/contextvars.html"><code>contextvars</code></a> 提供了用于管理、存储和访问上下文相关状态的相关 API。<code>ContextVar</code> 类用于声明 <strong>上下文变量</strong>（Context Variables） 并与其一起使用。函数 <code>copy_context()</code> 和类 <code>Context</code> 用于管理当前上下文和异步框架中。</p><p>在多并发环境中，有状态的上下文管理器应该使用 Context Variables，而不是 <a href="https://docs.python.org/3.10/library/threading.html#threading.local">threading.local()</a> 来防止他们的状态意外泄露到其他代码。更多信息参见 <a href="https://www.python.org/dev/peps/pep-0567">PEP 567</a>。</p><h2 id="上下文变量"><a href="#上下文变量" class="headerlink" title="上下文变量"></a>上下文变量</h2><h3 id="class-contextvars-ContextVar-name-default"><a href="#class-contextvars-ContextVar-name-default" class="headerlink" title="class contextvars.ContextVar(name[, *, default])"></a>class <code>contextvars.ContextVar(name[, *, default])</code></h3><p>此类用于声明一个新的上下文变量，如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> contextvars <span class="token keyword">import</span> ContextVarvar<span class="token punctuation">:</span> ContextVar<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span> <span class="token operator">=</span> ContextVar<span class="token punctuation">(</span><span class="token string">'var'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>name</code> 参数用于内省和调试，必需。调用 <code>ContextVar.get()</code> 时，如果上下文中没有找到此变量的值，则返回可选的仅命名参数 <code>default</code>。</p><p><strong>重要</strong>：上下文变量应该在顶级模块中创建，且永远不要在闭包中创建。<code>Context</code> 对象拥有对上下文变量的强引用，这可以让上下文变量被垃圾收集器正确回收。</p><p>下面介绍 <code>ContextVar</code> 对象的属性和方法：</p><ol><li><code>name</code>：上下文变量的名称，只读属性。</li><li><code>get([default])</code>：返回当前上下文中此上下文变量的值。如果当前上下文中此变量没有值，则此方法会：<ul><li>如果提供 <code>default</code> 值，则返回其值</li><li>返回上下文变量本身的默认值，如果创建此上下文变量时提供了默认值；或者</li><li>抛出 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#LookupError">LookupError</a> 异常</li></ul></li><li><code>set(value)</code>：调用此方法设置上下文变量在当前上下文中的值。必选参数 <code>value</code> 是上下文变量的新值。返回一个 <a href="https://docs.python.org/zh-cn/3.10/library/contextvars.html#contextvars.contextvars.Token">Token</a> 对象，可通过 <code>ContextVar.reset()</code> 方法将上下文变量还原为之前某个状态。</li><li><code>reset(token)</code>：将上下文变量重置为调用 <code>ContextVar.set()</code> 之前、创建 <code>token</code> 时候的状态。例如：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">var <span class="token operator">=</span> ContextVar<span class="token punctuation">(</span><span class="token string">'var'</span><span class="token punctuation">)</span>token <span class="token operator">=</span> var<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">'new value'</span><span class="token punctuation">)</span><span class="token comment"># code that uses 'var'; var.get() returns 'new value'.</span>var<span class="token punctuation">.</span>reset<span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token comment"># After the reset call the var has no value again, so</span><span class="token comment"># var.get() would raise a LookupError</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="class-contextvars-Token"><a href="#class-contextvars-Token" class="headerlink" title="class contextvars.Token"></a>class <code>contextvars.Token</code></h3><p><code>ContextVar.set()</code> 方法返回 <code>Token</code> 对象。此对象可以传递给 <code>ContextVar.reset()</code> 方法用于将上下文变量还原为调用 <code>set</code> 前的状态。</p><ul><li><code>Token.var</code>：只读属性。指向创建此 <code>token</code> 的 <code>ContextVar</code> 对象。</li><li><code>Token.old_value</code>：一个只读属性。会被设为在创建此令牌的 <code>ContextVar.set()</code> 方法调用之前该变量所具有的值。如果调用之前变量没有设置值，则它指向 <code>Token.MISSING</code></li><li><code>Token.MISSING</code>：<code>Token.old_value</code> 会用到的一个标记（marker）对象。</li></ul><h2 id="手动上下文管理"><a href="#手动上下文管理" class="headerlink" title="手动上下文管理"></a>手动上下文管理</h2><h3 id="contextvars-copy-context"><a href="#contextvars-copy-context" class="headerlink" title="contextvars.copy_context()"></a><code>contextvars.copy_context()</code></h3><p>返回当前上下文中 <code>Context</code> 对象的拷贝。</p><p>以下代码片段会获取当前上下文的拷贝并打印设置到其中的所有变量及其值：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ctx<span class="token punctuation">:</span> Context <span class="token operator">=</span> copy_context<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此函数复杂度为 $O(1)$，也就是说对于只包含几个上下文变量和很多上下文变量的情况，他们是一样快的。</p><h3 id="class-contextvars-Context"><a href="#class-contextvars-Context" class="headerlink" title="class contextvars.Context"></a>class <code>contextvars.Context</code></h3><p><code>ContextVar</code> 中所有值的映射。<code>Context()</code> 创建一个不包含任何值的空上下文。如果要获取当前上下文的拷贝，使用 <code>copy_context()</code> 函数。</p><p><code>Context</code> 实现了 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Mapping">collections.abc.Mapping</a> 接口。</p><h4 id="run-callable-args-kwargs"><a href="#run-callable-args-kwargs" class="headerlink" title="run(callable, *args, **kwargs)"></a><code>run(callable, *args, **kwargs)</code></h4><p>按照 <code>run</code> 方法中的参数在上下文对象中执行 <code>callable(*args, **kwargs)</code> 代码。返回执行结果，如果发生异常，则将异常 propagate 出来。</p><p><code>callable</code> 中对上下文变量做出的任何修改会保留在上下文对象中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">var <span class="token operator">=</span> ContextVar<span class="token punctuation">(</span><span class="token string">'var'</span><span class="token punctuation">)</span>var<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 'var' was set to 'spam' before</span>    <span class="token comment"># calling 'copy_context()' and 'ctx.run(main)', so:</span>    <span class="token comment"># var.get() == ctx[var] == 'spam'</span>    var<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">'ham'</span><span class="token punctuation">)</span>    <span class="token comment"># Now, after setting 'var' to 'ham':</span>    <span class="token comment"># var.get() == ctx[var] == 'ham'</span>ctx <span class="token operator">=</span> copy_context<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Any changes that the 'main' function makes to 'var'</span><span class="token comment"># will be contained in 'ctx'.</span>ctx<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token comment"># The 'main()' function was run in the 'ctx' context,</span><span class="token comment"># so changes to 'var' are contained in it:</span><span class="token comment"># ctx[var] == 'ham'</span><span class="token comment"># However, outside of 'ctx', 'var' is still set to 'spam':</span><span class="token comment"># var.get() == 'spam'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当在多个系统线程或者递归调用同一个上下文对象的此方法，抛出 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError">RuntimeError</a> 异常。</p><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a><code>copy()</code></h4><p>返回此上下文对象的浅拷贝。</p><h4 id="var-in-context"><a href="#var-in-context" class="headerlink" title="var in context"></a><code>var in context</code></h4><p>如果 <em>context</em> 中含有名称为 <code>var</code> 的变量，返回 <code>True</code>， 否则返回 <code>False</code>。</p><h4 id="context-var"><a href="#context-var" class="headerlink" title="context[var]"></a><code>context[var]</code></h4><p>返回名称为 <code>var</code> 的 <code>ContextVar</code> 变量。如果上下文对象中不包含这个变量，则抛出 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError"><code>KeyError</code></a> 异常。</p><h4 id="get-var-default"><a href="#get-var-default" class="headerlink" title="get(var[, default])"></a><code>get(var[, default])</code></h4><p>如果 <code>var</code> 在上下文对象中具有值则返回 <code>var</code> 的值。在其他情况下返回 <code>default</code>。如果未给出 <code>default</code> 则返回 <code>None</code>。</p><h4 id="iter-context"><a href="#iter-context" class="headerlink" title="iter(context)"></a><code>iter(context)</code></h4><p>返回一个存储在上下文对象中的变量的迭代器。</p><h4 id="len-proxy"><a href="#len-proxy" class="headerlink" title="len(proxy)"></a><code>len(proxy)</code></h4><p>返回上下文对象中所设的变量的数量。</p><h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a><code>keys()</code></h4><p>返回上下文对象中的所有变量的列表。</p><h4 id="values"><a href="#values" class="headerlink" title="values()"></a><code>values()</code></h4><p>返回上下文对象中所有变量值的列表。</p><h4 id="items"><a href="#items" class="headerlink" title="items()"></a><code>items()</code></h4><p>返回包含上下文对象中所有变量及其值的 2 元组的列表。</p><h2 id="asyncio-支持"><a href="#asyncio-支持" class="headerlink" title="asyncio 支持"></a>asyncio 支持</h2><p>上下文变量在 <code>asyncio</code> 中有原生的支持并且无需任何额外配置即可被使用。例如，以下是一个简单的回显服务器，它使用上下文变量来让远程客户端的地址在处理该客户端的 <code>Task</code> 中可用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> contextvarsclient_addr_var <span class="token operator">=</span> contextvars<span class="token punctuation">.</span>ContextVar<span class="token punctuation">(</span><span class="token string">'client_addr'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">render_goodbye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># The address of the currently handled client can be accessed</span>    <span class="token comment"># without passing it explicitly to this function.</span>    client_addr <span class="token operator">=</span> client_addr_var<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f'Good bye, client @ </span><span class="token interpolation"><span class="token punctuation">{</span>client_addr<span class="token punctuation">}</span></span><span class="token string">\n'</span></span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">handle_request</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> writer<span class="token punctuation">)</span><span class="token punctuation">:</span>    addr <span class="token operator">=</span> writer<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>get_extra_info<span class="token punctuation">(</span><span class="token string">'socket'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getpeername<span class="token punctuation">(</span><span class="token punctuation">)</span>    client_addr_var<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span>    <span class="token comment"># In any code that we call is now possible to get</span>    <span class="token comment"># client's address by calling 'client_addr_var.get()'.</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        line <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>render_goodbye<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    srv <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>start_server<span class="token punctuation">(</span>        handle_request<span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">8081</span><span class="token punctuation">)</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> srv<span class="token punctuation">:</span>        <span class="token keyword">await</span> srv<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># To test it you can use telnet:</span><span class="token comment">#     telnet 127.0.0.1 8081</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/contextvars/">contextvars</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/c4a5cb4d78b1.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>signal --- 设置异步事件处理程序</title>
      <link>https://xinetzone.github.io/post/zh-CN/a66b3bffc2fa.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/a66b3bffc2fa.html</guid>
      <pubDate>Tue, 20 Apr 2021 05:52:56 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;该模块提供了在 Python 中使用信号处理程序的机制。&lt;/p&gt;
&lt;h2 id=&quot;一般规则&quot;&gt;&lt;a href=&quot;#一般规则&quot; class=&quot;headerlink&quot; title=&quot;一般规则&quot;&gt;&lt;/a&gt;一般规则&lt;/h2&gt;&lt;p&gt;&lt;code&gt;signal.signal()&lt;/cod</description>
        
      
      
      
      <content:encoded><![CDATA[<p>该模块提供了在 Python 中使用信号处理程序的机制。</p><h2 id="一般规则"><a href="#一般规则" class="headerlink" title="一般规则"></a>一般规则</h2><p><code>signal.signal()</code> 函数允许定义在接收到信号时执行的自定义处理程序。少量的默认处理程序已经设置：<code>SIGPIPE</code> 被忽略（因此管道和套接字上的写入错误可以报告为普通的 Python 异常）以及如果父进程没有更改 <code>SIGINT</code>，则其会被翻译成 <code>KeyboardInterrupt</code> 异常。一旦设置，特定信号的处理程序将保持安装，直到它被显式重置（Python 模拟 BSD 样式接口而不管底层实现），但 <code>SIGCHLD</code> 的处理程序除外，它遵循底层实现。</p><h3 id="执行-Python-信号处理程序"><a href="#执行-Python-信号处理程序" class="headerlink" title="执行 Python 信号处理程序"></a>执行 Python 信号处理程序</h3><p>Python 信号处理程序不会在低级（ C ）信号处理程序中执行。相反，低级信号处理程序设置一个标志，告诉 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-virtual-machine">virtual machine</a> 稍后执行相应的 Python 信号处理程序（例如在下一个 bytecode 指令）。这会导致：</p><ul><li>捕获同步错误是没有意义的，例如 <code>SIGFPE</code> 或 <code>SIGSEGV</code>，它们是由 C 代码中的无效操作引起的。Python 将从信号处理程序返回到 C 代码，这可能会再次引发相同的信号，导致 Python 显然的挂起。从Python 3.3 开始，你可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/faulthandler.html#module-faulthandler"><code>faulthandler</code></a> 模块来报告同步错误。</li><li>纯 C 中实现的长时间运行的计算（例如在大量文本上的正则表达式匹配）可以在任意时间内不间断地运行，而不管接收到任何信号。计算完成后将调用 Python 信号处理程序。</li></ul><h3 id="信号与线程"><a href="#信号与线程" class="headerlink" title="信号与线程"></a>信号与线程</h3><p>Python 信号处理程序总是会在主 Python 主解释器的主线程中执行，即使信号是在另一个线程中接收的。这意味着信号不能被用作线程间通信的手段。你可以改用 <a href="https://docs.python.org/zh-cn/3.10/library/threading.html#module-threading">threading</a> 模块中的同步原语。</p><p>此外，只有主解释器的主线程才被允许设置新的信号处理程序。</p><p>更多内容见：<a href="https://learnku.com/docs/pymotw/signal-asynchronous-system-events/3420">11.3. signal — 同步系统事件</a></p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/signal/">signal</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/a66b3bffc2fa.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>事件调度器</title>
      <link>https://xinetzone.github.io/post/zh-CN/3e418adf5ef5.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/3e418adf5ef5.html</guid>
      <pubDate>Tue, 20 Apr 2021 05:27:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;sched&lt;/code&gt; 模块定义了一个实现通用事件调度程序的类：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-python&quot; data-language=&quot;python&quot;&gt;&lt;code class=&quot;language-python</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>sched</code> 模块定义了一个实现通用事件调度程序的类：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">sched</span><span class="token punctuation">.</span>scheduler<span class="token punctuation">(</span>timefunc<span class="token operator">=</span>time<span class="token punctuation">.</span>monotonic<span class="token punctuation">,</span> delayfunc<span class="token operator">=</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>scheduler</code> 类定义了一个调度事件的通用接口。它需要两个函数来实际处理“外部世界”：</p><ul><li><code>timefunc</code> 应当不带参数地调用，并返回一个数字（“time”，可以为任意单位）。</li><li><code>delayfunc</code> 函数应当带一个参数调用，与 <code>timefunc</code> 的输出相兼容，并且应当延迟其所指定的时间单位。每个事件运行后还将调用 <code>delayfunc</code> 并传入参数 <code>0</code> 以允许其他线程有机会在多线程应用中运行。</li></ul><p><code>scheduler</code> 类可以安全的在多线程环境中使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sched<span class="token punctuation">,</span> times <span class="token operator">=</span> sched<span class="token punctuation">.</span>scheduler<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">,</span> time<span class="token punctuation">.</span>sleep<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">print_time</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"From print_time"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">print_some_times</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>enter<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> print_time<span class="token punctuation">)</span>    s<span class="token punctuation">.</span>enter<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> print_time<span class="token punctuation">,</span> argument<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'positional'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>enter<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> print_time<span class="token punctuation">,</span> kwargs<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token string">'keyword'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>print_some_times<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><output class="xin-term">1618896750.4832535From print_time 1618896755.4988 keywordFrom print_time 1618896755.4988 positionalFrom print_time 1618896760.4886842 default1618896760.4886842</output><h2 id="调度器对象"><a href="#调度器对象" class="headerlink" title="调度器对象"></a>调度器对象</h2><p><code>scheduler</code> 实例拥有以下方法和属性：</p><ol><li><code>scheduler.enterabs(time, priority, action, argument=(), kwargs={})</code>：安排一个新事件。<code>time</code> 参数应该有一个数字类型兼容的返回值，与传递给构造函数的 <code>timefunc</code> 函数的返回值兼容。计划在相同 <code>time</code> 的事件将按其 <code>priority</code> 的顺序执行。数字越小表示优先级越高。执行事件意为执行 <code>action(*argument, **kwargs)</code>。<code>argument</code> 是包含有 <code>action</code> 的位置参数的序列。<code>kwargs</code> 是包含 <code>action</code> 的关键字参数的字典。返回值是一个事件，可用于以后取消事件（ 参见 <code>cancel()</code> ）。</li><li><code>scheduler.enter(delay, priority, action, argument=(), kwargs={})</code>：安排延后 <code>delay</code> 时间单位的事件。除了相对时间，其他参数、效果和返回值与 <code>enterabs()</code> 的相同。</li><li><code>scheduler.cancel(event)</code>：从队列中删除事件。如果 <code>event</code> 不是当前队列中的事件，则此方法将引发 <code>ValueError</code>。</li><li><code>scheduler.empty()</code>：如果事件队列为空则返回 <code>True</code>。</li><li><code>scheduler.run(blocking=True)</code>：运行所有预定事件。此方法将等待（使用传递给构造函数的 <code>delayfunc()</code> 函数）进行下一个事件，然后执行它，依此类推，直到没有更多的计划事件。如果 <code>blocking</code> 为 false，则执行由于最快到期（如果有）的预定事件，然后在调度程序中返回下一个预定调用的截止时间（如果有）。<code>action</code> 或 <code>delayfunc</code> 都可以引发异常。在任何一种情况下，调度程序都将保持一致状态并传播异常。如果 <code>action</code> 引发异常，则在将来调用 <code>run()</code> 时不会尝试该事件。如果一系列事件的运行时间比下一个事件之前的可用时间长，那么调度程序将完全落后。不会发生任何事件；调用代码负责取消不再相关的事件。</li><li><code>scheduler.queue</code>：只读属性按照将要运行的顺序返回即将发生的事件列表。每个事件都显示为 named tuple ，包含以下字段：<code>time</code>、<code>priority</code>、<code>action</code>、<code>argument</code>、<code>kwargs</code>。</li></ol>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/sched/">sched</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/3e418adf5ef5.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>subprocess --- 子进程管理</title>
      <link>https://xinetzone.github.io/post/zh-CN/b10be92a5827.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/b10be92a5827.html</guid>
      <pubDate>Mon, 19 Apr 2021 08:23:22 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;subprocess&lt;/code&gt; 具有可访问的 I/O 流的子进程。该模块允许您生成进程，连接到其 &lt;code&gt;input/output/error&lt;/code&gt; 管道并获取其返回码。主要 API 有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;run(...)&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>subprocess</code> 具有可访问的 I/O 流的子进程。该模块允许您生成进程，连接到其 <code>input/output/error</code> 管道并获取其返回码。主要 API 有：</p><ol><li><code>run(...)</code>：运行命令，等待命令完成，然后返回 <code>CompletedProcess</code> 实例。</li><li><code>Popen(...)</code>：用于在新进程中灵活执行命令的类。</li></ol><p>常量：</p><ol><li><code>DEVNULL</code>：指示应使用 <code>os.devnull</code> 的特殊值。</li><li><code>PIPE</code>：指示应创建管道的特殊值。</li><li><code>STDOUT</code>：指示 <code>stderr</code> 应该转到 <code>stdout</code> 的特殊值。</li></ol><p>过时的 API（函数 <code>run()</code> ，<code>call()</code>，<code>check_call()</code> 和 <code>check_output()</code> 是 <code>Popen</code> 类的包装。直接使用 <code>Popen</code> 能够对如何运行命令以及如何处理输入输出流提供更多的控制。例如，通过对 <code>stdin</code>，<code>stdout</code> 以及 <code>stderr</code> 传递不同的参数，可以达到模仿 <code>os.popen()</code> 的效果）：</p><ul><li><code>call(...)</code>：运行命令，等待它完成，然后获取其返回码。</li><li><code>check_call(...)</code>：与 <code>call()</code> 相同，但如果返回码不为 0，则会引发 <code>CalledProcessError()</code></li><li><code>check_output(...)</code>：与 <code>check_call()</code> 相同，但返回 <code>stdout</code> 的内容，而不是返回码。</li><li><code>getoutput(...)</code>：在 shell 中运行命令，等待它完成，然后返回输出。</li><li><code>getstatusoutput(...)</code>：在 shell 中运行命令，等待它完成，然后返回 <code>(exitcode, output)</code> 元组。</li></ul><h2 id="Popen"><a href="#Popen" class="headerlink" title="Popen"></a>Popen</h2><p>由于 <code>subprocess</code> 中的各种 API 均与 <code>Popen</code> 相关，所以，我先了解该对象。</p><p>class <code>Popen</code> 在新进程中执行子程序。有如下参数：</p><ol><li><code>args</code>：字符串或程序参数序列。<code>args</code> 被所有调用需要，应当为一个字符串，或者一个程序参数序列。提供一个参数序列通常更好，它可以更小心地使用参数中的转义字符以及引用（例如允许文件名中的空格）。如果传递一个简单的字符串，则 <code>shell</code> 参数必须为 <code>True</code> （见下文）或者该字符串中将被运行的程序名必须用简单的命名而不指定任何参数。</li><li><code>bufsize</code>：在创建 <code>stdin/stdout/stderr</code> 管道文件对象时作为 <code>open()</code> 函数的 <code>buffering</code> 参数提供。<ul><li><code>0</code> 表示不使用缓冲区 （读取与写入是一个系统调用并且可以返回短内容）</li><li><code>1</code> 表示行缓冲（只有 <code>universal_newlines=True</code> 时才有用，例如，在文本模式中）</li><li>任何其他正值表示使用一个约为对应大小的缓冲区</li><li>负的 <code>bufsize</code> （默认）表示使用系统默认的 <code>io.DEFAULT_BUFFER_SIZE</code>。</li></ul></li><li><code>executable</code>：要执行的替换程序。这很少需要。当 <code>shell=True</code>， <code>executable</code> 替换 <code>args</code> 指定运行的程序。但是，原始的 <code>args</code> 仍然被传递给程序。大多数程序将被 <code>args</code> 指定的程序作为命令名对待，这可以与实际运行的程序不同。在 POSIX， <code>args</code> 名作为实际调用程序中可执行文件的显示名称，例如 <code>ps</code>。如果 <code>shell=True</code>，在 POSIX， <code>executable</code> 参数指定用于替换默认 shell <code>/bin/sh</code> 的 shell。在 POSIX 上 <code>executable</code> 形参可以接受一个 path-like object。在Windows 上 <code>executable</code> 形参可以接受一个字节串和 path-like object。</li><li><code>stdin</code>，<code>stdout</code> 和 <code>stderr</code>：它们分别指定执行程序的标准输入，标准输出和标准错误文件句柄。合法的值有 <code>PIPE</code>， <code>DEVNULL</code>， 一个存在的文件描述符（一个正整数），一个存在的 文件对象 以及 <code>None</code>。 <code>PIPE</code> 表示应创建一个新的对子进程的管道。<code>DEVNULL</code> 表示使用特殊的 <code>os.devnull</code> 文件。使用默认的 <code>None</code>，则不进行成定向；子进程的文件流将继承自父进程。另外， <code>stderr</code> 可设为 <code>STDOUT</code>，表示应用程序的标准错误数据应和标准输出一同捕获。</li><li><code>preexec_fn</code>：（仅适用于 POSIX）在执行子进程之前要在子进程中调用的对象。（仅 POSIX）如果 <code>preexec_fn</code> 被设为一个可调用对象，此对象将在子进程刚创建时被调用。</li><li><code>close_fds</code>：控制文件描述符（file descriptors）的关闭或继承。如果 <code>close_fds</code> 为真，所有文件描述符除了 0, 1, 2 之外都会在子进程执行前关闭。而当 <code>close_fds</code> 为 false 时，文件描述符遵守它们继承的标志，如 <a href="https://docs.python.org/zh-cn/3/library/os.html#fd-inheritance">文件描述符的继承</a> 所述。</li><li><code>shell</code>：如果为 true，则将通过 shell 执行该命令。</li><li><code>cwd</code>：在执行子进程之前设置当前目录。如果 <code>cwd</code> 不为 <code>None</code>，此函数在执行子进程前会将当前工作目录改为 <code>cwd</code>。<code>cwd</code> 可以是一个字符串、字节串或 路径类对象。特别地，当可执行文件的路径为相对路径时，此函数会相对于 <em>cwd</em> 来查找 <code>executable</code> (或 <code>args</code> 中的第一项)。</li><li><code>env</code>：定义新进程的环境变量。如果 <code>env</code> 不为 <code>None</code>，则必须为一个为新进程定义了环境变量的字典；这些用于替换继承的当前进程环境的默认行为。如果指定， <code>env</code> 必须提供所有被子进程需求的变量。在 Windows，为了运行一个 <a href="https://en.wikipedia.org/wiki/Side-by-Side_Assembly">side-by-side assembly</a>，指定的 <code>env</code> <strong>必须</strong> 包含一个有效的 <code>SystemRoot</code>。</li><li><code>text</code>：如果为 true，则使用给定的 <code>encoding</code>。（如果设置）对 stdin，stdout 和 stderr 进行解码，否则使用系统默认值。</li><li><code>universal_newlines</code>：<code>text</code> 的别名，为向后兼容而提供。</li><li><code>startupinfo</code> 和 <code>creationflags</code>（仅适用于 Windows）</li><li><code>restore_signals</code> （仅适用于 POSIX）</li><li><code>start_new_session</code>（仅适用于 POSIX）</li><li><code>group</code>（仅适用于 POSIX）</li><li><code>extra_groups</code>（仅适用于 POSIX）</li><li><code>user</code>（仅适用于 POSIX）</li><li><code>umask</code>（仅适用于 POSIX）</li><li><code>pass_fds</code>（仅适用于 POSIX）</li><li><code>encoding</code> 和 <code>errors</code>：用于文件对象 <code>stdin</code>，<code>stdout</code> 和 <code>stderr</code> 的文本模式编码和错误处理。</li></ol><p>该实例有属性：<code>stdin</code>, <code>stdout</code>, <code>stderr</code>, <code>pid</code>, <code>returncode</code>。</p><p>实例创建：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Popen</span><span class="token punctuation">:</span>    _child_created <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># Set here since __del__ checks it</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> args<span class="token punctuation">,</span> bufsize<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> executable<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>                 stdin<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> stdout<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> stderr<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>                 preexec_fn<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> close_fds<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                 shell<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> cwd<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> env<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> universal_newlines<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>                 startupinfo<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> creationflags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>                 restore_signals<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> start_new_session<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                 pass_fds<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> user<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> group<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> extra_groups<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>                 encoding<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> errors<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> text<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> umask<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> pipesize<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>subprocess</code> 模块的底层的进程创建与管理由 <code>Popen</code> 类处理。它提供了很大的灵活性，因此开发者能够处理未被便捷函数覆盖的不常见用例。</p><p>在新进程中执行子程序。在 POSIX 上，该类使用类似于 <code>os.execvpe()</code> 的行为来执行子程序。在 Windows 上，该类使用 Windows <code>CreateProcess()</code> 函数。<code>Popen</code> 的参数如下：</p><p><code>args</code> 应当是一个程序参数的序列或者是一个单独的字符串或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-like-object">path-like object</a>。默认情况下，如果 <code>args</code> 是序列则要运行的程序为 <code>args</code> 中的第一项。如果 <code>args</code> 是字符串，则其解读依赖于具体平台，如下所述。 请查看 <code>shell</code> 和 <code>executable</code> 参数了解其与默认行为的其他差异。除非另有说明，否则推荐以序列形式传入 <code>args</code>。</p><div class="w3-pale-red">警告：为了获得最大的可靠性，请为可执行文件使用完全限定的路径。要在 PATH 上搜索不合格的名称，请使用 shutil.which()。在所有平台上，建议再次传递 sys.executable 来启动当前的 Python 解释器，并使用 -m 命令行格式来启动已安装的模块。</div><p>向外部函数传入序列形式参数的一个例子如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/usr/bin/git"</span><span class="token punctuation">,</span> <span class="token string">"commit"</span><span class="token punctuation">,</span> <span class="token string">"-m"</span><span class="token punctuation">,</span> <span class="token string">"Fixes a bug."</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 POSIX，如果 <code>args</code> 是一个字符串，此字符串被作为将被执行的程序的命名或路径解释。但是，只有在不传递任何参数给程序的情况下才能这么做。</p><div class="w3-card-2 w3-pale-blue w3-padding"><i>注解</i>：将 shell 命令拆分为参数序列的方式可能并不很直观，特别是在复杂的情况下。<code>shlex.split()</code> 可以演示如何确定 <code>args</code> 适当的拆分形式：<pre class="line-numbers language-python" data-language="python"><code class="language-python">Type <span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"copyright"</span><span class="token punctuation">,</span> <span class="token string">"credits"</span> <span class="token keyword">or</span> <span class="token string">"license"</span> <span class="token keyword">for</span> more information<span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> shlex<span class="token punctuation">,</span> subprocess<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> command_line <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>vikings <span class="token operator">-</span><span class="token builtin">input</span> eggs<span class="token punctuation">.</span>txt <span class="token operator">-</span>output <span class="token string">"spam spam.txt"</span> <span class="token operator">-</span>cmd <span class="token string">"echo '$MONEY'"</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> args <span class="token operator">=</span> shlex<span class="token punctuation">.</span>split<span class="token punctuation">(</span>command_line<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'/bin/vikings'</span><span class="token punctuation">,</span> <span class="token string">'-input'</span><span class="token punctuation">,</span> <span class="token string">'eggs.txt'</span><span class="token punctuation">,</span> <span class="token string">'-output'</span><span class="token punctuation">,</span> <span class="token string">'spam spam.txt'</span><span class="token punctuation">,</span> <span class="token string">'-cmd'</span><span class="token punctuation">,</span> <span class="token string">"echo '$MONEY'"</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> p <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token comment"># Success!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别注意，由 shell 中的空格分隔的选项（例如 -input）和参数（例如 eggs.txt ）位于分开的列表元素中，而在需要时使用引号或反斜杠转义的参数在 shell（例如包含空格的文件名或上面显示的 echo 命令）是单独的列表元素。</p></div><p>在 Windows，如果 <code>args</code> 是一个序列，他将通过一个在 <a href="https://docs.python.org/zh-cn/3.10/library/subprocess.html#converting-argument-sequence">Windows 上将参数列表转换为一个字符串</a> 描述的方式被转换为一个字符串。这是因为底层的 CreateProcess() 只处理字符串。</p><p><code>Popen</code> 对象支持通过 <code>with</code> 语句作为上下文管理器，在退出时关闭文件描述符并等待进程：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"ifconfig"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">)</span> <span class="token keyword">as</span> proc<span class="token punctuation">:</span>    log<span class="token punctuation">.</span>write<span class="token punctuation">(</span>proc<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Popen-对象"><a href="#Popen-对象" class="headerlink" title="Popen 对象"></a>Popen 对象</h3><p>Popen 类的实例拥有以下方法：</p><ol><li><code>Popen.poll()</code>：检查子进程是否已被终止。设置并返回 <code>returncode</code> 属性。否则返回 <code>None</code>。</li><li><code>Popen.wait(timeout=None)</code>：等待子进程被终止。设置并返回 <code>returncode</code> 属性。如果进程在 <code>timeout</code> 秒后未中断，抛出一个 <code>TimeoutExpired</code> 异常，可以安全地捕获此异常并重新等待。<blockquote><p>注解：当 <code>stdout=PIPE</code> 或者 <code>stderr=PIPE</code> 并且子进程产生了足以阻塞 OS 管道缓冲区接收更多数据的输出到管道时，将会发生死锁。当使用管道时用 <code>Popen.communicate()</code> 来规避它。<br>注解：此函数使用了一个 busy loop （非阻塞调用以及短睡眠）实现。使用 <code>asyncio</code> 模块进行异步等待： 参阅 <a href="https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html#asyncio.create_subprocess_exec">asyncio.create_subprocess_exec</a>。</p></blockquote></li><li><code>Popen.communicate(input=None, timeout=None)</code> 与进程交互：将数据发送到 <code>stdin</code>。从 <code>stdout</code> 和 <code>stderr</code> 读取数据，直到抵达文件结尾。等待进程终止并设置 <code>returncode</code> 属性。可选的 <code>input</code> 参数应为要发送到下级进程的数据，或者如果没有要发送到下级进程的数据则为 <code>None</code>。如果流是以文本模式打开的，则 <code>input</code> 必须为字符串。在其他情况下，它必须为字节串。</li></ol><p><code>communicate()</code> 返回一个 <code>(stdout_data, stderr_data)</code> 元组。如果文件以文本模式打开则为字符串；否则字节。注意如果你想要向进程的 <code>stdin</code> 传输数据，你需要通过 <code>stdin=PIPE</code> 创建此 <code>Popen</code> 对象。类似的，要从结果元组获取任何非 <code>None</code> 值，你同样需要设置 <code>stdout=PIPE</code> 或者 <code>stderr=PIPE</code>。</p><p>如果进程在 <code>timeout</code> 秒后未终止，一个 <code>TimeoutExpired</code> 异常将被抛出。捕获此异常并重新等待将不会丢失任何输出。如果超时到期，子进程不会被杀死，所以为了正确清理一个行为良好的应用程序应该杀死子进程并完成通讯。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    outs<span class="token punctuation">,</span> errs <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token keyword">except</span> TimeoutExpired<span class="token punctuation">:</span>    proc<span class="token punctuation">.</span>kill<span class="token punctuation">(</span><span class="token punctuation">)</span>    outs<span class="token punctuation">,</span> errs <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注解：内存里数据读取是缓冲的，所以如果数据尺寸过大或无限，不要使用此方法。</p></blockquote><ol start="4"><li><code>Popen.send_signal(signal)</code>：将信号 <code>signal</code> 发送给子进程。如果进程已完成则不做任何操作。</li></ol><blockquote><p>注解：在 Windows， <code>SIGTERM</code> 是一个 <a href="https://docs.python.org/zh-cn/3/library/subprocess.html#subprocess.Popen.terminate"><code>terminate()</code></a> 的别名。<code>CTRL_C_EVENT</code> 和 <code>CTRL_BREAK_EVENT</code> 可以被发送给以包含 <code>CREATE_NEW_PROCESS</code> 的 <code>creationflags</code> 形参启动的进程。</p></blockquote><ol start="5"><li><code>Popen.terminate()</code>：停止子进程。在 POSIX 操作系统上，此方法会发送 <code>SIGTERM</code> 给子进程。在 Windows 上则会调用 Win32 API 函数 <code>TerminateProcess()</code> 来停止子进程。</li><li><code>Popen.kill()</code>：杀死子进程。在 POSIX 操作系统上，此函数会发送 <code>SIGKILL</code> 给子进程。在 Windows 上 <code>kill()</code> 则是 <code>terminate()</code> 的别名。</li></ol><p>以下属性也是可用的：</p><ul><li>Popen.args：传递给 <code>Popen</code> – 一个程序参数的序列或者一个简单字符串</li><li><code>Popen.stdin</code>：如果 <code>stdin</code> 参数为 PIPE，此属性是一个类似 <code>open()</code> 返回的可写的流对象。如果 <code>encoding</code> 或 <code>errors</code> 参数被指定或者 <code>universal_newlines</code> 参数为 <code>True</code>，则此流是一个文本流，否则是字节流。如果 <code>stdin</code> 参数非 <code>PIPE</code>， 此属性为 <code>None</code>。</li><li><code>Popen.stdout</code>：如果 <code>stdout</code> 参数是 <code>PIPE</code>，此属性是一个类似 o<code>pen()</code> 返回的可读流。从流中读取子进程提供的输出。如果 <code>encoding</code> 或 <code>errors</code> 参数被指定或者 <code>universal_newlines</code> 参数为 <code>True</code>，此流为文本流，否则为字节流。如果 <code>stdout</code> 参数非 ·，此属性为 <code>None</code>。</li><li><code>Popen.stderr</code>：如果 <code>stderr</code> 参数是 <code>PIPE</code>，此属性是一个类似 <code>open()</code> 返回的可读流。从流中读取子进程提供的输出。如果 <code>encoding</code> 或 <code>errors</code> 参数被指定或者 <code>universal_newlines</code> 参数为 <code>True</code>，此流为文本流，否则为字节流。如果 <code>stderr</code> 参数非 <code>PIPE</code>，此属性为 <code>None</code>。</li></ul><div class="w3-pale-red">警告：使用 <code>communicate()</code> 而非 <code>.stdin.write</code>， <code>.stdout.read</code> 或者 <code>.stderr.read</code> 来避免由于任意其他 OS 管道缓冲区被子进程填满阻塞而导致的死锁。</div><ol start="7"><li><code>Popen.pid</code>：子进程的进程号。注意如果你设置了 <code>shell</code> 参数为 <code>True</code>，则这是生成的子 <code>shell</code> 的进程号。</li><li><code>Popen.returncode</code>：此进程的退出码，由 <code>poll()</code> 和 <code>wait()</code> 设置（以及直接由 <code>communicate()</code> 设置）。一个 <code>None</code> 值 表示此进程仍未结束。一个负值 <code>-N</code> 表示子进程被信号 <code>N</code> 中断 (仅 POSIX).</li></ol><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p><code>subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None, **other_popen_kwargs)</code> 运行被 <code>arg</code> 描述的指令。等待指令完成，然后返回一个 <a href="https://docs.python.org/zh-cn/3.10/library/subprocess.html#subprocess.CompletedProcess">CompletedProcess</a> 实例。以上显示的参数仅仅是最简单的一些，下面 <a href="https://docs.python.org/zh-cn/3.10/library/subprocess.html#frequently-used-arguments">常用参数</a> 描述（因此在缩写签名中使用仅关键字标示）。完整的函数头和 Popen 的构造函数一样，此函数接受的大多数参数都被传递给该接口。（<code>timeout</code>, <code>input</code>, <code>check</code> 和 <code>capture_output</code> 除外）。</p><p>如果 <code>capture_output</code> 设为 <code>true</code>，<code>stdout</code> 和 <code>stderr</code> 将会被捕获。在使用时，内置的 <code>Popen</code> 对象将自动用 <code>stdout=PIPE</code> 和 <code>stderr=PIPE</code> 创建。<code>stdout</code> 和 <code>stderr</code> 参数不应当与 <code>capture_output</code> 同时提供。如果你希望捕获并将两个流合并在一起，使用 <code>stdout=PIPE</code> 和 <code>stderr=STDOUT</code> 来代替 <code>capture_output</code>。</p><p><code>timeout</code> 参数将被传递给 <a href="https://docs.python.org/zh-cn/3.10/library/subprocess.html#subprocess.Popen.communicate">Popen.communicate()</a>。如果发生超时，子进程将被杀死并等待。 <code>TimeoutExpired</code> 异常将在子进程中断后被抛出。</p><p><code>input</code> 参数将被传递给 <code>Popen.communicate()</code> 以及子进程的标准输入。如果使用此参数，它必须是一个字节序列。如果指定了 <code>encoding</code> 或 <code>errors</code> 或者将 <code>text</code> 设置为 <code>True</code>，那么也可以是一个字符串。当使用此参数时，在创建内部 <code>Popen</code> 对象时将自动带上 <code>stdin=PIPE</code>，并且不能再手动指定 <code>stdin</code> 参数。</p><p>如果 <code>check</code> 设为 <code>True</code>, 并且进程以非零状态码退出, 一个 <code>CalledProcessError</code> 异常将被抛出。这个异常的属性将设置为参数, 退出码, 以及标准输出和标准错误, 如果被捕获到。</p><p>如果 <code>encoding</code> 或者 <code>error</code> 被指定, 或者 <code>text</code> 被设为 <code>True</code>, 标准输入, 标准输出和标准错误的文件对象将通过指定的 <code>encoding</code> 和 <code>errors</code> 以文本模式打开, 否则以默认的 <code>io.TextIOWrapper</code> 打开。<code>universal_newline</code> 参数等同于 <code>text</code> 并且提供了向后兼容性。默认情况下, 文件对象是以二进制模式打开的。</p><p>如果 <code>env</code> 不是 <code>None</code>, 它必须是一个字典, 为新的进程设置环境变量; 它用于替换继承的当前进程的环境的默认行为. 它将直接被传递给 <code>Popen</code>。</p><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># doesn't capture output</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><output class="xin-term">CompletedProcess(args=['ls', '-l'], returncode=0)</output><pre class="line-numbers language-python" data-language="python"><code class="language-python">subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">"exit 1"</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> check<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><output class="xin-term">Traceback (most recent call last):  ...subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1</output><pre class="line-numbers language-python" data-language="python"><code class="language-python">subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token string">"/dev/null"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> capture_output<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><output class="xin-term">CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\n', stderr=b'')</output><p>如果仅仅是为了运行一个外部命令而不用交互，类似 <code>os.system()</code>，可以使用 <code>run()</code> 方法。比如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_os_system.py</span><span class="token keyword">import</span> subprocesscompleted <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'ls'</span><span class="token punctuation">,</span> <span class="token string">'-l'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'returncode:'</span><span class="token punctuation">,</span> completed<span class="token punctuation">.</span>returncode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令行参数被作为一个字符串列表传入，这样能够避免转义引号以及其他会被 <code>shell</code> 解析的特殊字符。<code>run()</code> 方法返回一个 <code>CompletedProcess</code> 实例，包含进程退出码以及输出等信息。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python subprocess_os_system.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><output class="xin-term">__pycache__a.pyceleba.pyloader.pytest.pyvision.pyreturncode: 0</output><p>设置 <code>shell</code> 参数为 <code>True</code> 会导致 <code>subprocess</code> 创建一个新的中间 <code>shell</code> 进程运行命令。默认的行为是直接运行命令。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_shell_variables.py</span><span class="token keyword">import</span> subprocesscompleted <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">'echo $HOME'</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'returncode:'</span><span class="token punctuation">,</span> completed<span class="token punctuation">.</span>returncode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用中间 <code>shell</code> 意味着在运行该命令之前处理命令字符串的变量，<code>glob</code> 模式以及其他特殊的 <code>shell</code> 功能。</p><blockquote><p>使用 <code>run()</code> 而没有传递 <code>check=True</code> 等价于调用 <code>call()</code>，它仅仅返回进程的退出码。给 <code>run()</code> 方法传递 <code>check=True</code> 等价于调用 <code>check_all()</code>。</p></blockquote><p>由 <code>run()</code> 启动的进程的标准输入输出渠道绑定在了父进程上。那就意味着调用程序不能捕获命令的输出。给 <code>stdout</code> 和 <code>stderr</code> 参数传递 <code>PIPE</code> 可以捕获输出用于后续处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_run_output.py</span><span class="token keyword">import</span> subprocesscompleted <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token string">'ls'</span><span class="token punctuation">,</span> <span class="token string">'-1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'returncode:'</span><span class="token punctuation">,</span> completed<span class="token punctuation">.</span>returncode<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Have {} bytes in stdout:\n{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>    <span class="token builtin">len</span><span class="token punctuation">(</span>completed<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">,</span>    completed<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ls -1</code> 命令成功运行了，所以它打印到标准输出的文本被捕获并返回了。</p><output class="xin-term">returncode: 0Have 55 bytes in stdout:__pycache__a.pyceleba.pyloader.pytest.pyvision.py</output><blockquote><p>传入 <code>check=True</code> 以及设置 <code>stdout</code> 为 <code>PIPE</code> 等价于使用 <code>check_output()</code>。</p></blockquote><p>下个例子在子 <code>shell</code> 中运行了一些命令。在命令出错退出之前消息被发送到了标准输出和错误输出。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_run_output_error.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">try</span><span class="token punctuation">:</span>    completed <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span>        <span class="token string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span><span class="token punctuation">,</span>        check<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token keyword">except</span> subprocess<span class="token punctuation">.</span>CalledProcessError <span class="token keyword">as</span> err<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ERROR:'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'returncode:'</span><span class="token punctuation">,</span> completed<span class="token punctuation">.</span>returncode<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Have {} bytes in stdout: {!r}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>        <span class="token builtin">len</span><span class="token punctuation">(</span>completed<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">,</span>        completed<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准错误输出被打印到了控制台，但是标准错误输出被隐藏了。</p><output class="xin-term">to stdout; echo to stderr ; exit 1returncode: 0Have 0 bytes in stdout: ''</output><p>为了阻止 <code>run()</code> 运行命令产生的错误消息打印到控制台，设置 <code>stderr</code> 参数为常量 <code>PIPE</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_run_output_error_trap.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">try</span><span class="token punctuation">:</span>    completed <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span>        <span class="token string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span><span class="token punctuation">,</span>        shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>        stderr<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token keyword">except</span> subprocess<span class="token punctuation">.</span>CalledProcessError <span class="token keyword">as</span> err<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ERROR:'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'returncode:'</span><span class="token punctuation">,</span> completed<span class="token punctuation">.</span>returncode<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Have {} bytes in stdout: {!r}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>        <span class="token builtin">len</span><span class="token punctuation">(</span>completed<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">,</span>        completed<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Have {} bytes in stderr: {!r}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>        <span class="token builtin">len</span><span class="token punctuation">(</span>completed<span class="token punctuation">.</span>stderr<span class="token punctuation">)</span><span class="token punctuation">,</span>        completed<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子没有设置 <code>check=True</code>，所以命令的输出被捕获并且打印。</p><output class="xin-term">returncode: 0Have 0 bytes in stdout: ''Have 36 bytes in stderr: 'to stdout; echo to stderr ; exit 1\r\n'</output><p>为了捕获当使用 <code>check_output()</code> 产生的错误消息时，设置 <code>stderr</code> 为 <code>STDOUT</code>，并且这些消息将与该命令的其余输出合并。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_check_output_error_trap_output.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">try</span><span class="token punctuation">:</span>    output <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>check_output<span class="token punctuation">(</span>        <span class="token string">'echo to stdout; echo to stderr 1&gt;&amp;2'</span><span class="token punctuation">,</span>        shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        stderr<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>STDOUT<span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token keyword">except</span> subprocess<span class="token punctuation">.</span>CalledProcessError <span class="token keyword">as</span> err<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ERROR:'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Have {} bytes in output: {!r}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>        <span class="token builtin">len</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">,</span>        output<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出顺序可能会变化，取决于对标准输出流的缓冲方式以及打印的数据量。</p><output class="xin-term">Have 28 bytes in output: 'to stdout; echo to stderr \r\n'</output><p><strong>抑制输出</strong>：某些情况下，输出不应该被展示和捕获，使用 <code>DEVNULL</code> 抑制输出流。这个例子抑制了标准输出流和错误输出流。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_run_output_error_suppress.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">try</span><span class="token punctuation">:</span>    completed <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span>        <span class="token string">'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1'</span><span class="token punctuation">,</span>        shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>DEVNULL<span class="token punctuation">,</span>        stderr<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>DEVNULL<span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token keyword">except</span> subprocess<span class="token punctuation">.</span>CalledProcessError <span class="token keyword">as</span> err<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ERROR:'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'returncode:'</span><span class="token punctuation">,</span> completed<span class="token punctuation">.</span>returncode<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'stdout is {!r}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>completed<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'stderr is {!r}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>completed<span class="token punctuation">.</span>stderr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>DEVNULL</code> 的名字来自于 Unix 特殊的设备文件，<code>/dev/null</code>，当读时直接响应文件结束，写时接收但忽略任何数量的输入。</p><output class="xin-term">stdout is Nonestderr is None</output><h3 id="与进程单向通信"><a href="#与进程单向通信" class="headerlink" title="与进程单向通信"></a>与进程单向通信</h3><p>为了去运行一个进程以及读取所有它的输出，设置 <code>stdout</code> 的值为 <code>PIPE</code> 并且调用 <code>communicate()</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_popen_read.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'read:'</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token string">'echo'</span><span class="token punctuation">,</span> <span class="token string">'"to stdout"'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>stdout_value <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'stdout:'</span><span class="token punctuation">,</span> <span class="token builtin">repr</span><span class="token punctuation">(</span>stdout_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个类似于 <code>popen()</code> 的工作方式，除了读取由 <code>Popen</code> 实例内部管理。</p><output class="xin-term">read:stdout: '"to stdout"\n'</output><p>为了设置一个管道允许调用者向其写入数据，设置 <code>stdin</code> 为 <code>PIPE</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_popen_write.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'write:'</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    stdin<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span><span class="token string">'stdin: to stdin\n'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><output class="xin-term">write:stdin: to stdin</output><h3 id="与进程双向通信"><a href="#与进程双向通信" class="headerlink" title="与进程双向通信"></a>与进程双向通信</h3><p>为了设置 Popen 实例同时进行读写，请结合之前使用过的技术。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_popen2.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'popen2:'</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    stdin<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>msg <span class="token operator">=</span> <span class="token string">'through stdin to stdout'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>stdout_value <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'pass through:'</span><span class="token punctuation">,</span> <span class="token builtin">repr</span><span class="token punctuation">(</span>stdout_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样设置使用就有点像 <code>popen2()</code> 了。</p><output class="xin-term">popen2:pass through: 'through stdin to stdout'</output><h3 id="捕获错误输出"><a href="#捕获错误输出" class="headerlink" title="捕获错误输出"></a>捕获错误输出</h3><p>同时查看 <code>stdout</code> 和 <code>stderr</code> 输出流也是可能的，就像 <code>popen3()</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_popen3.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'popen3:'</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token string">'cat -; echo "to stderr" 1&gt;&amp;2'</span><span class="token punctuation">,</span>    shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    stdin<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    stderr<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>msg <span class="token operator">=</span> <span class="token string">'through stdin to stdout'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>stdout_value<span class="token punctuation">,</span> stderr_value <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'pass through:'</span><span class="token punctuation">,</span> <span class="token builtin">repr</span><span class="token punctuation">(</span>stdout_value<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'stderr      :'</span><span class="token punctuation">,</span> <span class="token builtin">repr</span><span class="token punctuation">(</span>stderr_value<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 <code>stderr</code> 中读取错误输出类似于 <code>stdout</code>。传入 <code>PIPE</code> 告诉 <code>Popen</code> 附加到通道，并且使用 <code>communicate()</code> 在返回之前读取所有数据。</p><output class="xin-term">popen3:pass through: 'through stdin to stdout'stderr      : 'to stderr\n'</output><h3 id="合并常规和错误输出"><a href="#合并常规和错误输出" class="headerlink" title="合并常规和错误输出"></a>合并常规和错误输出</h3><p>为了将进程的错误输出导向标准输出渠道，设置 <code>stderr</code> 为 <code>STDOUT</code> 而不是 <code>PIPE</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_popen4.py</span><span class="token keyword">import</span> subprocess<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'popen4:'</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token string">'cat -; echo "to stderr" 1&gt;&amp;2'</span><span class="token punctuation">,</span>    shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    stdin<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    stderr<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>STDOUT<span class="token punctuation">,</span><span class="token punctuation">)</span>msg <span class="token operator">=</span> <span class="token string">'through stdin to stdout\n'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>stdout_value<span class="token punctuation">,</span> stderr_value <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'combined output:'</span><span class="token punctuation">,</span> <span class="token builtin">repr</span><span class="token punctuation">(</span>stdout_value<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'stderr value   :'</span><span class="token punctuation">,</span> <span class="token builtin">repr</span><span class="token punctuation">(</span>stderr_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种合并输出的方式类似于 <code>popen4()</code> 的工作方式。</p><output class="xin-term">popen4:combined output: 'through stdin to stdout\nto stderr\n'stderr value   : None</output><p><code>subprocess</code> 模块允许你生成新的进程，连接它们的输入、输出、错误管道，并且获取它们的返回码。推荐的调用子进程的方式是在任何它支持的用例中使用 <code>run()</code> 函数。对于更进阶的用例，也可以使用底层的 <code>Popen</code> 接口。</p><h2 id="连接管道的段"><a href="#连接管道的段" class="headerlink" title="连接管道的段"></a>连接管道的段</h2><p>多个命令可以被连接到一个 管道 中，类似于 Unix shell 的工作方式，实现这种操作，可以通过创建分隔的 <code>Popen</code> 实例并将他们的输入输出链在一起。一个 <code>Popen</code> 实例的 <code>stdout</code> 属性被用作下一个的 <code>stdin</code> 参数，而不是之前的常量 <code>PIPE</code>。要获取整个执行的输出，可以从最后一个 <code>Popen</code> 实例的 <code>stdout</code> 流读取。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_pipes.py</span><span class="token keyword">import</span> subprocesscat <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'index.rst'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>grep <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token string">'grep'</span><span class="token punctuation">,</span> <span class="token string">'.. literalinclude::'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    stdin<span class="token operator">=</span>cat<span class="token punctuation">.</span>stdout<span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>cut <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token string">'cut'</span><span class="token punctuation">,</span> <span class="token string">'-f'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'-d:'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    stdin<span class="token operator">=</span>grep<span class="token punctuation">.</span>stdout<span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>end_of_pipe <span class="token operator">=</span> cut<span class="token punctuation">.</span>stdout<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Included files:'</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> end_of_pipe<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子同下面的命令行操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">cat</span> index.rst <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">".. literalinclude"</span> <span class="token operator">|</span> <span class="token function">cut</span> -f <span class="token number">3</span> -d:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个部分首先管道读取 <code>reStructuredText</code> 源文件，然后找到所有包含其他文件的行，最后打印被包含的文件名称。</p><h2 id="同另一个命令交互"><a href="#同另一个命令交互" class="headerlink" title="同另一个命令交互"></a>同另一个命令交互</h2><p>所有前面的例子都假定了一个有限的交互，<code>communicate()</code> 方法读取所有输出并等待子进程在返回之前退出。在程序运行时也可以逐步写入和读取 <code>Popen</code> 实例使用的单个管道句柄。从标准输入中读取并希望如标准输出的简单回声程序说明了这种技术。</p><p>脚本 <code>repeater.py</code> 被用作下一个例子的子进程。它从 <code>stdin</code> 读取并且写入到 <code>stdout</code> ，一次一行，直到再没有输入。当开始和停止的时候，它也往 <code>stderr</code> 写入了一条消息，展示子进程的声明周期。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># repeater.py</span><span class="token keyword">import</span> syssys<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'repeater.py: starting\n'</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    next_line <span class="token operator">=</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>    sys<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> next_line<span class="token punctuation">:</span>        <span class="token keyword">break</span>    sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>write<span class="token punctuation">(</span>next_line<span class="token punctuation">)</span>    sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'repeater.py: exiting\n'</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一个例子中以不同的方式使用 <code>Popen</code> 实例的 <code>stdin</code> 和 <code>stdout</code> 文件句柄。在第一个例子中，五个数字被依次写入到进程的 <code>stdin</code>，每次写入后，紧接着会读出输入并打印出来了。第二个例子中相同的五个数字被写入，但是输出通过 <code>communicate()</code> 依次行读取了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># interaction.py</span><span class="token keyword">import</span> io<span class="token keyword">import</span> subprocess<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'One line at a time:'</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token string">'python3 repeater.py'</span><span class="token punctuation">,</span>    shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    stdin<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>stdin <span class="token operator">=</span> io<span class="token punctuation">.</span>TextIOWrapper<span class="token punctuation">(</span>    proc<span class="token punctuation">.</span>stdin<span class="token punctuation">,</span>    encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span>    line_buffering<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>  <span class="token comment"># send data on newline</span><span class="token punctuation">)</span>stdout <span class="token operator">=</span> io<span class="token punctuation">.</span>TextIOWrapper<span class="token punctuation">(</span>    proc<span class="token punctuation">.</span>stdout<span class="token punctuation">,</span>    encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    line <span class="token operator">=</span> <span class="token string">'{}\n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>    output <span class="token operator">=</span> stdout<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>remainder <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>remainder<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'All output at once:'</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token string">'python3 repeater.py'</span><span class="token punctuation">,</span>    shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    stdin<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>    stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span><span class="token punctuation">)</span>stdin <span class="token operator">=</span> io<span class="token punctuation">.</span>TextIOWrapper<span class="token punctuation">(</span>    proc<span class="token punctuation">.</span>stdin<span class="token punctuation">,</span>    encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    line <span class="token operator">=</span> <span class="token string">'{}\n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>stdin<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>output <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个循环中， <code>"repeater.py: exiting"</code> 行在输出的不同点出现。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 -u interaction.pyOne line at a time:repeater.py: starting<span class="token number">0</span><span class="token number">1</span><span class="token number">2</span><span class="token number">3</span><span class="token number">4</span>repeater.py: exitingAll output at once:repeater.py: startingrepeater.py: exiting<span class="token number">0</span><span class="token number">1</span><span class="token number">2</span><span class="token number">3</span><span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进程间的信号"><a href="#进程间的信号" class="headerlink" title="进程间的信号"></a>进程间的信号</h2><p><code>os</code> 模块的进程管理示例包括使了用 <code>os.fork()</code> 和 <code>os.kill()</code> 进程之间的信号演示。由于每个 <code>Popen</code> 实例都提供了一个 <code>pid</code> 属性和子进程 <code>id</code>，所以可以对子进程执行类似的操作。下一个例子合并了两个脚本，子进程设置了一个 <code>USR</code> 信号处理器。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># signal_child.py</span><span class="token keyword">import</span> os<span class="token keyword">import</span> signal<span class="token keyword">import</span> time<span class="token keyword">import</span> syspid <span class="token operator">=</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span>received <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">signal_usr1</span><span class="token punctuation">(</span>signum<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token string">"Callback invoked when a signal is received"</span>    <span class="token keyword">global</span> received    received <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'CHILD {:&gt;6}: Received USR1'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span>    sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'CHILD {:&gt;6}: Setting up signal handler'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>signal<span class="token punctuation">.</span>signal<span class="token punctuation">(</span>signal<span class="token punctuation">.</span>SIGUSR1<span class="token punctuation">,</span> signal_usr1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'CHILD {:&gt;6}: Pausing to wait for signal'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token keyword">not</span> received<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'CHILD {:&gt;6}: Never received signal'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个脚本被当做父进程运行，它启动了 <code>signal_child.py</code>，然后发送了 <code>USR1</code> 信号。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># signal_parent.py</span><span class="token keyword">import</span> os<span class="token keyword">import</span> signal<span class="token keyword">import</span> subprocess<span class="token keyword">import</span> time<span class="token keyword">import</span> sysproc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'python3'</span><span class="token punctuation">,</span> <span class="token string">'signal_child.py'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'PARENT      : Pausing before sending signal...'</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'PARENT      : Signaling child'</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>kill<span class="token punctuation">(</span>proc<span class="token punctuation">.</span>pid<span class="token punctuation">,</span> signal<span class="token punctuation">.</span>SIGUSR1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出是：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 signal_parent.pyPARENT      <span class="token builtin class-name">:</span> Pausing before sending signal<span class="token punctuation">..</span>.CHILD  <span class="token number">26976</span>: Setting up signal handlerCHILD  <span class="token number">26976</span>: Pausing to <span class="token function">wait</span> <span class="token keyword">for</span> signalPARENT      <span class="token builtin class-name">:</span> Signaling childCHILD  <span class="token number">26976</span>: Received USR1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进程-组-会话"><a href="#进程-组-会话" class="headerlink" title="进程 组 / 会话"></a>进程 组 / 会话</h2><p>如果由 <code>Popen</code> 创建的进程产生子进程，那么子进程将不会收到任何发送给父进程的任何信号。这意味着当对 <code>Popen</code> 使用 <code>shell</code> 参数时，很难通过发送 <code>SIGINT</code> 和 <code>SIGTERM</code> 来使 <code>shell</code> 中启动的命令终止。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_signal_parent_shell.py</span><span class="token keyword">import</span> os<span class="token keyword">import</span> signal<span class="token keyword">import</span> subprocess<span class="token keyword">import</span> tempfile<span class="token keyword">import</span> time<span class="token keyword">import</span> sysscript <span class="token operator">=</span> <span class="token triple-quoted-string string">'''#!/bin/shecho "Shell script in process $$"set -xpython3 signal_child.py'''</span>script_file <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>NamedTemporaryFile<span class="token punctuation">(</span><span class="token string">'wt'</span><span class="token punctuation">)</span>script_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>script<span class="token punctuation">)</span>script_file<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> script_file<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'PARENT      : Pausing before signaling {}...'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>    proc<span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'PARENT      : Signaling child {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>proc<span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>kill<span class="token punctuation">(</span>proc<span class="token punctuation">.</span>pid<span class="token punctuation">,</span> signal<span class="token punctuation">.</span>SIGUSR1<span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于发送信号的 <code>pid</code> 与等待信号的运行 <code>shell</code> 脚本的子进程 <code>id</code> 不同，因为这个例子中有三个独立的进程在交互：</p><ol><li>主程序&nbsp;<code>subprocess_signal_parent_shell.py</code></li><li>主程序创建的运行脚本的 <code>shell</code> 进程。</li><li>程序 <code>signal_child.py</code></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">$ python3 subprocess_signal_parent_shell<span class="token punctuation">.</span>pyPARENT      <span class="token punctuation">:</span> Pausing before signaling <span class="token number">26984</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Shell script <span class="token keyword">in</span> process <span class="token number">26984</span><span class="token operator">+</span> python3 signal_child<span class="token punctuation">.</span>pyCHILD  <span class="token number">26985</span><span class="token punctuation">:</span> Setting up signal handlerCHILD  <span class="token number">26985</span><span class="token punctuation">:</span> Pausing to wait <span class="token keyword">for</span> signalPARENT      <span class="token punctuation">:</span> Signaling child <span class="token number">26984</span>CHILD  <span class="token number">26985</span><span class="token punctuation">:</span> Never received signal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要在不知道进程 <code>id</code> 的情况下向后代进程发送信号，请使用进程组关联这些子进程，以便可以一起发送信号。进程组使用 <code>os.setpgrp()</code> 创建，它将进程组 <code>id</code> 设置为当前进程 <code>id</code>。所有子进程都从父进程继承他们的进程组，因为它只应在由 <code>Popen</code> 及其后代创建的 <code>shell</code> 中设置，所以不应在创建 <code>Popen</code> 的相同进程中调用 <code>os.setpgrp()</code>。而是，应在作为 <code>Popen</code> 的 <code>preexec_fn</code> 参数设置的函数中调用，它会在新进程的 <code>fork</code> 之后运行，在用 <code>exec</code> 运行 <code>shell</code> 之前。为了给进程组发送信号，应该使用 <code>os.killpg()</code> 并使用 <code>Popen</code> 实例的进程 <code>id</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># subprocess_signal_setpgrp.py</span><span class="token keyword">import</span> os<span class="token keyword">import</span> signal<span class="token keyword">import</span> subprocess<span class="token keyword">import</span> tempfile<span class="token keyword">import</span> time<span class="token keyword">import</span> sys<span class="token keyword">def</span> <span class="token function">show_setting_prgrp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Calling os.setpgrp() from {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>setpgrp<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Process group is now {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpgrp<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>script <span class="token operator">=</span> <span class="token triple-quoted-string string">'''#!/bin/shecho "Shell script in process $$"set -xpython3 signal_child.py'''</span>script_file <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>NamedTemporaryFile<span class="token punctuation">(</span><span class="token string">'wt'</span><span class="token punctuation">)</span>script_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>script<span class="token punctuation">)</span>script_file<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> script_file<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">,</span>    preexec_fn<span class="token operator">=</span>show_setting_prgrp<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'PARENT      : Pausing before signaling {}...'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>    proc<span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'PARENT      : Signaling process group {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>    proc<span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>killpg<span class="token punctuation">(</span>proc<span class="token punctuation">.</span>pid<span class="token punctuation">,</span> signal<span class="token punctuation">.</span>SIGUSR1<span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个运行流程如下：</p><ol><li>父进程实例化&nbsp;<code>Popen</code>；</li><li><code>Popen</code>&nbsp;实例 <code>fork</code> 新进程；</li><li>新进程运行&nbsp;<code>os.setpgrp()</code>；</li><li>新进程运行 <code>exec()</code>&nbsp;启动 shell；</li><li>shell 运行脚本；</li><li>shell 脚本再次 <code>fork</code>，然后启动 Python 解释器；<br>7。 Python 运行&nbsp;<code>signal_child.py</code>.</li><li>父进程发送信号非进程组，使用 <code>Popen</code> 实例的进程 <code>id</code>；</li><li>shell and Python 程序收到信号；</li><li>shell 忽略掉了信号。</li><li>运行&nbsp;<code>signal_child.py</code> 的 Python 程序&nbsp;调用了信号处理器。</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python3 subprocess_signal_setpgrp.pyCalling os.setpgrp<span class="token punctuation">(</span><span class="token punctuation">)</span> from <span class="token number">75636</span>Process group is now <span class="token number">75636</span>PARENT      <span class="token builtin class-name">:</span> Pausing before signaling <span class="token number">75636</span><span class="token punctuation">..</span>.Shell script <span class="token keyword">in</span> process <span class="token number">75636</span>+ python3 signal_child.pyCHILD  <span class="token number">75637</span>: Setting up signal handlerCHILD  <span class="token number">75637</span>: Pausing to <span class="token function">wait</span> <span class="token keyword">for</span> signalPARENT      <span class="token builtin class-name">:</span> Signaling process group <span class="token number">75636</span>CHILD  <span class="token number">75637</span>: Received USR1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/subprocess/">subprocess</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/b10be92a5827.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>执行 网络 IO 和 IPC</title>
      <link>https://xinetzone.github.io/post/zh-CN/a8441a397d6a.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/a8441a397d6a.html</guid>
      <pubDate>Mon, 19 Apr 2021 07:19:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;流是用于处理网络连接的支持 &lt;code&gt;async/await&lt;/code&gt; 的高层级原语（primitives）。流允许发送和接收数据，而不需要使用回调或低级协议和传输。&lt;/p&gt;
&lt;p&gt;下面是一个使用 asyncio streams 编写的 TCP echo 客户端示例：</description>
        
      
      
      
      <content:encoded><![CDATA[<p>流是用于处理网络连接的支持 <code>async/await</code> 的高层级原语（primitives）。流允许发送和接收数据，而不需要使用回调或低级协议和传输。</p><p>下面是一个使用 asyncio streams 编写的 TCP echo 客户端示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">tcp_echo_client</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">:</span>    reader<span class="token punctuation">,</span> writer <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>open_connection<span class="token punctuation">(</span>        <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Send: </span><span class="token interpolation"><span class="token punctuation">{</span>message<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> writer<span class="token punctuation">.</span>drain<span class="token punctuation">(</span><span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Received: </span><span class="token interpolation"><span class="token punctuation">{</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Close the connection'</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> writer<span class="token punctuation">.</span>wait_closed<span class="token punctuation">(</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>tcp_echo_client<span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Stream-函数"><a href="#Stream-函数" class="headerlink" title="Stream 函数"></a>Stream 函数</h2><p>下面的高级 <code>asyncio</code> 函数可以用来创建和处理流：</p><ol><li>coroutine <code>asyncio.open_connection(host=None, port=None, *, loop=None, limit=None, ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None)</code> 建立网络连接并返回一对 <code>(reader, writer)</code> 对象。</li></ol><p>返回的 <code>reader</code> 和 <code>writer</code> 对象是 <a href="https://docs.python.org/zh-cn/3/library/asyncio-stream.html#asyncio.StreamReader">StreamReader</a> 和 <a href="https://docs.python.org/zh-cn/3/library/asyncio-stream.html#asyncio.StreamWriter">StreamWriter</a> 类的实例。</p><p><code>loop</code> 参数是可选的，当从协程中等待该函数时，总是可以自动确定。<code>limit</code> 确定返回的 <code>StreamReader</code> 实例使用的缓冲区大小限制。默认情况下，<code>limit</code> 设置为 64 KiB 。其余的参数直接传递到 <code>loop.create_connection()</code>。</p><ol start="2"><li>coroutine <code>asyncio.start_server(client_connected_cb, host=None, port=None, *, loop=None, limit=None, family=socket.AF_UNSPEC, flags=socket.AI_PASSIVE, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, start_serving=True)</code> 启动套接字服务。</li></ol><p>当一个新的客户端连接被建立时，回调函数 <code>client_connected_cb</code> 会被调用。该函数会接收到一对参数 <code>(reader, writer)</code> ，<code>reader</code> 是类 <code>StreamReader</code> 的实例，而 <code>writer</code> 是类 <code>StreamWriter</code> 的实例。</p><p><code>client_connected_cb</code> 可以是普通的可调用对象也可以是一个 协程函数; 如果它是一个协程函数，它将自动作为 Task 被调度。<code>loop</code> 参数是可选的。当在一个协程中 <code>await</code> 该方法时，该参数始终可以自动确定。<code>loop</code> 参数是可选的，当从协程中等待该函数时，总是可以自动确定。<code>limit</code> 确定返回的 <code>StreamReader</code> 实例使用的缓冲区大小限制。默认情况下，<code>limit</code> 设置为 64 KiB 。其余的参数直接传递到 <code>loop.create_connection()</code>。</p><ol start="3"><li><p>coroutine <code>asyncio.open_unix_connection(path=None, *, loop=None, limit=None, ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None)</code> 建立一个 <strong>Unix 套接字</strong>连接并返回 <code>(reader, writer)</code> 这对返回值。与 <code>open_connection()</code> 相似，但是是在 Unix 套接字上的操作。请看文档 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_unix_connection">loop.create_unix_connection()</a>.</p></li><li><p>coroutine <code>asyncio.start_unix_server(client_connected_cb, path=None, *, loop=None, limit=None, sock=None, backlog=100, ssl=None, ssl_handshake_timeout=None, start_serving=True)</code><br>启动一个 Unix 套接字服务。与 <code>start_server()</code> 相似，但是是在 Unix 套接字上的操作。请看文档 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_unix_server">loop.create_unix_server()</a>.</p></li></ol><h2 id="StreamReader"><a href="#StreamReader" class="headerlink" title="StreamReader"></a>StreamReader</h2><p>class <code>asyncio.StreamReader</code> 表示一个读取器对象，该对象提供 <code>api</code> 以便于从 IO 流中读取数据。</p><p>不推荐直接实例化 <code>StreamReader</code> 对象，建议使用 <code>open_connection()</code> 和 <code>start_server()</code> 来获取 <code>StreamReader</code> 实例。</p><ol><li>coroutine <code>read(n=-1)</code> 至多读取 n 个 byte。如果没有设置 <code>n</code> , 则自动置为 <code>-1</code> ， <code>-1</code> 时表示读至 EOF 并返回所有读取的 byte。如果读到 EOF，且内部缓冲区为空，则返回一个空的 <code>bytes</code> 对象。</li><li>coroutine <code>readline()</code> 读取一行，其中“行”指的是以 <code>\n</code> 结尾的字节序列。如果读到 EOF 而没有找到 <code>\n</code>，该方法返回部分读取的数据。如果读到 EOF，且内部缓冲区为空，则返回一个空的 <code>bytes</code> 对象。</li><li>coroutine <code>readexactly(n)</code> 精确读取 <code>n</code> 个 <code>bytes</code>，不会超过也不能少于。如果在读取完 <code>n</code> 个 byte 之前读取到 EOF，则会引发 <code>IncompleteReadError</code> 异常。使用 <code>IncompleteReadError.partial</code> 属性来获取到达流结束之前读取的 <code>bytes</code> 字符串。</li><li>coroutine <code>readuntil(separator=b'\n')</code> 从流中读取数据直至遇到 <code>separator</code>。成功后，数据和指定的 <code>separator</code> 将从内部缓冲区中删除(或者说被消费掉)。返回的数据将包括在末尾的指定 <code>separator</code>。</li></ol><p>如果读取的数据量超过了配置的流限制，将引发 <code>LimitOverrunError</code> 异常，数据将留在内部缓冲区中并可以再次读取。如果在找到完整的 <code>separator</code> 之前到达 EOF，则会引发 <code>IncompleteReadError</code> 异常，并重置内部缓冲区。<code>IncompleteReadError.partial</code> 属性可能包含指定 <code>separator</code> 的一部分。</p><ol start="5"><li><code>at_eof()</code>：如果缓冲区为空并且 <code>feed_eof()</code> 被调用，则返回 <code>True</code>。</li></ol><h2 id="StreamWriter"><a href="#StreamWriter" class="headerlink" title="StreamWriter"></a>StreamWriter</h2><p>class <code>asyncio.StreamWriter</code> 表示一个写入器对象，该对象提供 <code>api</code> 以便于写数据至 IO 流中。不建议直接实例化 StreamWriter；而应改用 <code>open_connection()</code> 和 <code>start_server()</code>。</p><ol><li><code>write(data)</code> 方法会尝试立即将 <code>data</code> 写入到下层的套接字。如果写入失败，数据会被排入内部写缓冲队列直到可以被发送。此方法应当与 <code>drain()</code> 方法一起使用：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">stream<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">await</span> stream<span class="token punctuation">.</span>drain<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><code>writelines(data)</code> 方法会立即尝试将一个字节串列表（或任何可迭代对象）写入到下层的套接字。如果写入失败，数据会被排入内部写缓冲队列直到可以被发送。此方法应当与 <code>drain()</code> 方法一起使用：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">stream<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token keyword">await</span> stream<span class="token punctuation">.</span>drain<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li><code>close()</code> 方法会关闭流以及下层的套接字。此方法应与 <code>wait_closed()</code> 方法一起使用：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">stream<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">await</span> stream<span class="token punctuation">.</span>wait_closed<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li><code>can_write_eof()</code>：如果下层的传输支持 · 方法则返回 <code>True</code>，否则返回 <code>False</code>。</li><li><code>write_eof()</code> 在已缓冲的写入数据被刷新后关闭流的写入端。</li><li><code>transport</code> 返回下层的 <code>asyncio</code> 传输。</li><li><code>get_extra_info(name, default=None)</code> 访问可选的传输信息；详情参见 <a href="https://docs.python.org/zh-cn/3/library/asyncio-protocol.html#asyncio.BaseTransport.get_extra_info">BaseTransport.get_extra_info()</a>。</li><li><code>coroutine drain()</code> 等待直到可以适当地恢复写入到流。示例:</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">await</span> writer<span class="token punctuation">.</span>drain<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是一个与下层的 IO 写缓冲区进行交互的流程控制方法。当缓冲区大小达到最高水位（最大上限）时，<code>drain()</code> 会阻塞直到缓冲区大小减少至最低水位以便恢复写入。当没有要等待的数据时，<code>drain()</code> 会立即返回。</p><ol start="9"><li><code>is_closing()</code> 如果流已被关闭或正在被关闭则返回 <code>True</code>。</li><li>coroutine <code>wait_closed()</code> 等待直到流被关闭。应当在 <code>close()</code> 之后被调用以便等待直到下层的连接被关闭。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="使用流的-TCP-回显客户端"><a href="#使用流的-TCP-回显客户端" class="headerlink" title="使用流的 TCP 回显客户端"></a>使用流的 TCP 回显客户端</h3><p>使用 <code>asyncio.open_connection()</code> 函数的 TCP 回显客户端：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">tcp_echo_client</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">:</span>    reader<span class="token punctuation">,</span> writer <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>open_connection<span class="token punctuation">(</span>        <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Send: </span><span class="token interpolation"><span class="token punctuation">{</span>message<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Received: </span><span class="token interpolation"><span class="token punctuation">{</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Close the connection'</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>tcp_echo_client<span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参见：使用低层级 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_connection">loop.create_connection()</a> 方法的 <a href="https://docs.python.org/zh-cn/3/library/asyncio-protocol.html#asyncio-example-tcp-echo-client-protocol">TCP 回显客户端协议</a> 示例。</p><h4 id="使用流的-TCP-回显服务器"><a href="#使用流的-TCP-回显服务器" class="headerlink" title="使用流的 TCP 回显服务器"></a>使用流的 TCP 回显服务器</h4><p>TCP 回显服务器使用 <code>asyncio.start_server()</code> 函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">handle_echo</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> writer<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    message <span class="token operator">=</span> data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    addr <span class="token operator">=</span> writer<span class="token punctuation">.</span>get_extra_info<span class="token punctuation">(</span><span class="token string">'peername'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Received </span><span class="token interpolation"><span class="token punctuation">{</span>message<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string"> from </span><span class="token interpolation"><span class="token punctuation">{</span>addr<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Send: </span><span class="token interpolation"><span class="token punctuation">{</span>message<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">await</span> writer<span class="token punctuation">.</span>drain<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Close the connection"</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    server <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>start_server<span class="token punctuation">(</span>        handle_echo<span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span>    addr <span class="token operator">=</span> server<span class="token punctuation">.</span>sockets<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>getsockname<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Serving on </span><span class="token interpolation"><span class="token punctuation">{</span>addr<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> server<span class="token punctuation">:</span>        <span class="token keyword">await</span> server<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参见 使用 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_server">loop.create_server()</a> 方法的 TCP <a href="https://docs.python.org/zh-cn/3/library/asyncio-protocol.html#asyncio-example-tcp-echo-server-protocol">回显服务器协议</a> 示例。</p><h3 id="获取-HTTP-标头"><a href="#获取-HTTP-标头" class="headerlink" title="获取 HTTP 标头"></a>获取 HTTP 标头</h3><p>查询命令行传入 URL 的 HTTP 标头的简单示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>parse<span class="token keyword">import</span> sys<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">print_http_headers</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    url <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>urlsplit<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">if</span> url<span class="token punctuation">.</span>scheme <span class="token operator">==</span> <span class="token string">'https'</span><span class="token punctuation">:</span>        reader<span class="token punctuation">,</span> writer <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>open_connection<span class="token punctuation">(</span>            url<span class="token punctuation">.</span>hostname<span class="token punctuation">,</span> <span class="token number">443</span><span class="token punctuation">,</span> ssl<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        reader<span class="token punctuation">,</span> writer <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>open_connection<span class="token punctuation">(</span>            url<span class="token punctuation">.</span>hostname<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span>    query <span class="token operator">=</span> <span class="token punctuation">(</span>        <span class="token string-interpolation"><span class="token string">f"HEAD </span><span class="token interpolation"><span class="token punctuation">{</span>url<span class="token punctuation">.</span>path <span class="token keyword">or</span> <span class="token string">'/'</span><span class="token punctuation">}</span></span><span class="token string"> HTTP/1.0\r\n"</span></span>        <span class="token string-interpolation"><span class="token string">f"Host: </span><span class="token interpolation"><span class="token punctuation">{</span>url<span class="token punctuation">.</span>hostname<span class="token punctuation">}</span></span><span class="token string">\r\n"</span></span>        <span class="token string-interpolation"><span class="token string">f"\r\n"</span></span>    <span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>query<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'latin-1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        line <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> line<span class="token punctuation">:</span>            <span class="token keyword">break</span>        line <span class="token operator">=</span> line<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'latin1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> line<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'HTTP header&gt; </span><span class="token interpolation"><span class="token punctuation">{</span>line<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token comment"># Ignore the body, close the socket</span>    writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>url <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>print_http_headers<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用法:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python example.py http://example.com/path/page.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或使用 HTTPS：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python example.py https://example.com/path/page.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="注册一个打开的套接字以等待使用流的数据"><a href="#注册一个打开的套接字以等待使用流的数据" class="headerlink" title="注册一个打开的套接字以等待使用流的数据"></a>注册一个打开的套接字以等待使用流的数据</h3><p>使用 <code>open_connection()</code> 函数实现等待直到套接字接收到数据的协程：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> socket<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">wait_for_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Get a reference to the current event loop because</span>    <span class="token comment"># we want to access low-level APIs.</span>    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Create a pair of connected sockets.</span>    rsock<span class="token punctuation">,</span> wsock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socketpair<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Register the open socket to wait for data.</span>    reader<span class="token punctuation">,</span> writer <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>open_connection<span class="token punctuation">(</span>sock<span class="token operator">=</span>rsock<span class="token punctuation">)</span>    <span class="token comment"># Simulate the reception of data from the network</span>    loop<span class="token punctuation">.</span>call_soon<span class="token punctuation">(</span>wsock<span class="token punctuation">.</span>send<span class="token punctuation">,</span> <span class="token string">'abc'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># Wait for data</span>    data <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token comment"># Got data, we are done: close the socket</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Received:"</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Close the second socket</span>    wsock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>wait_for_data<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参见：使用低层级协议以及 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_connection">loop.create_connection()</a> 方法的 <a href="https://docs.python.org/zh-cn/3/library/asyncio-protocol.html#asyncio-example-create-connection">注册一个打开的套接字以等待使用协议的数据</a> 示例。<br>使用低层级的 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.add_reader">loop.add_reader()</a> 方法来监视文件描述符的 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio-example-watch-fd">监视文件描述符以读取事件</a> 示例。</p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/asyncio/">asyncio</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/a8441a397d6a.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python 异步编程</title>
      <link>https://xinetzone.github.io/post/zh-CN/bc778a9a2e3c.html</link>
      <guid>https://xinetzone.github.io/post/zh-CN/bc778a9a2e3c.html</guid>
      <pubDate>Mon, 19 Apr 2021 05:19:49 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;future&lt;/code&gt; 是代表尚未完成的工作结果的数据结构。事件循环可以监视将 &lt;code&gt;Future&lt;/code&gt; 对象设置为完成的状态，从而允许应用程序的一部分等待另一部分完成某些工作。除 &lt;code&gt;future&lt;/code&gt; 外，&lt;code&gt;asy</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>future</code> 是代表尚未完成的工作结果的数据结构。事件循环可以监视将 <code>Future</code> 对象设置为完成的状态，从而允许应用程序的一部分等待另一部分完成某些工作。除 <code>future</code> 外，<code>asyncio</code> 还包括其他并发原语，例如锁和信号量（semaphores）。</p><p><code>Task</code> 是 <code>Future</code> 的子类，它知道如何包装和管理协程的执行。可以使用事件循环调度任务，以在所需资源可用时运行它们，并产生可以被其他协程消耗的结果。</p><h2 id="Awaitables"><a href="#Awaitables" class="headerlink" title="Awaitables"></a>Awaitables</h2><p>若一个对象可以被用于 <code>await</code> 表达式，则可被称为<dfn class="xin-term">可等待</dfn>（awaitable）对象。<dfn class="xin-term">可等待</dfn> 对象有三种主要类型: <dfn class="xin-term">协程</dfn>（coroutines）, <dfn class="xin-term">任务</dfn>（Tasks） 和 <dfn class="xin-term">Futures</dfn>。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><dfn class="xin-term">协程</dfn> 通过 <code>async/await</code> 语法进行声明，是编写 asyncio 应用的推荐方式。例如，以下代码段（需要 Python 3.7+）会打印 “hello”，等待 1 秒，再打印 “world”：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> asyncio<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：简单地调用一个协程并不会使其被调度（schedule）执行</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>coroutine <span class="token builtin">object</span> main at <span class="token number">0x1053bb7c8</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要真正运行一个协程，asyncio 提供了三种主要机制:</p><ul><li><code>asyncio.run()</code> 函数用来运行最高层级的入口点 “main()” 函数 (参见上面的示例。)</li><li>等待一个协程。以下代码段会在等待 1 秒后打印 “hello”，然后 再次 等待 2 秒后打印 “world”：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> time<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">say_after</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> what<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>what<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"started at </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">await</span> say_after<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> say_after<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'world'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"finished at </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>预期的输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">started at <span class="token number">17</span>:13:52helloworldfinished at <span class="token number">17</span>:13:55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>asyncio.create_task()</code> 函数用来并发运行作为 asyncio <strong>任务</strong> 的多个协程。</li></ul><p>修改以上示例，<strong>并发</strong>（concurrently）运行两个 <code>say_after</code> 协程:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    task1 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>        say_after<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    task2 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>        say_after<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"started at </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token comment"># Wait until both tasks are completed (should take</span>    <span class="token comment"># around 2 seconds.)</span>    <span class="token keyword">await</span> task1    <span class="token keyword">await</span> task2    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"finished at </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，预期的输出显示代码段的运行时间比之前快了 1 秒：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">started at <span class="token number">17</span>:14:32helloworldfinished at <span class="token number">17</span>:14:34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Python <i>协程</i> 属于 可等待 对象，因此可以在其他协程中被等待：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">42</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Nothing happens if we just call "nested()".</span>    <span class="token comment"># A coroutine object is created but not awaited,</span>    <span class="token comment"># so it *won't run at all*.</span>    nested<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Let's do it differently now and await it:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token keyword">await</span> nested<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># will print "42".</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span class="w3-yellow">重要</span> ：<dfn class="xin-term">协程</dfn> 一般有两个紧密关联的概念:</p><ul><li><dfn class="xin-term">协程函数</dfn>: 定义形式为 <code>async def</code> 的函数;</li><li><dfn class="xin-term">协程对象</dfn>: 调用 协程函数 所返回的对象。</li></ul><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p><dfn class="xin-term">任务</dfn> 被用来“并发的”（concurrently）调度协程。当一个协程通过 <code>asyncio.create_task()</code> 等函数被封装为一个 <strong>任务</strong>，该协程会被自动调度执行：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">42</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Schedule nested() to run soon concurrently</span>    <span class="token comment"># with "main()".</span>    task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>nested<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># "task" can now be used to cancel "nested()", or</span>    <span class="token comment"># can simply be awaited to wait until it is complete:</span>    <span class="token keyword">await</span> taskasyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h3><p><dfn class="xin-term">Future</dfn> 是一种特殊的 <strong>低层级</strong> 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p><p>当一个 Future 对象 被等待，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。</p><p>在 asyncio 中需要 <dfn class="xin-term">Future</dfn> 对象以便允许通过 async/await 使用基于回调的代码。</p><p>通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 <dfn class="xin-term">Future</dfn> 对象。</p><p><dfn class="xin-term">Future</dfn> 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">await</span> function_that_returns_a_future_object<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># this is also valid:</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>        function_that_returns_a_future_object<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        some_python_coroutine<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个很好的返回对象的低层级函数的示例是 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor"><code>loop.run_in_executor()</code></a>。</p><h2 id="在-Jupyter-Notebook-中使用异步编程"><a href="#在-Jupyter-Notebook-中使用异步编程" class="headerlink" title="在 Jupyter Notebook 中使用异步编程"></a>在 Jupyter Notebook 中使用异步编程</h2><p>在 Jupyter Notebook 中使用 <code>asyncio.run()</code> 时会触发异常：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">---------------------------------------------------------------------------RuntimeError                              Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token operator">&lt;</span>ipython-input-5-eaadc83a82ea<span class="token operator">&gt;</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>----<span class="token operator">&gt;</span> <span class="token number">1</span> asyncio.run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">))</span>~<span class="token punctuation">\</span>anaconda3<span class="token punctuation">\</span>envs<span class="token punctuation">\</span>ui<span class="token punctuation">\</span>lib<span class="token punctuation">\</span>asyncio<span class="token punctuation">\</span>runners.py <span class="token keyword">in</span> run<span class="token punctuation">(</span>main, debug<span class="token punctuation">)</span>     <span class="token number">31</span>     <span class="token string">""</span>"     <span class="token number">32</span>     <span class="token keyword">if</span> events._get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span> is not None:---<span class="token operator">&gt;</span> <span class="token number">33</span>         raise RuntimeError<span class="token punctuation">(</span>     <span class="token number">34</span>             <span class="token string">"asyncio.run() cannot be called from a running event loop"</span><span class="token punctuation">)</span>     <span class="token number">35</span> RuntimeError: asyncio.run<span class="token punctuation">(</span><span class="token punctuation">)</span> cannot be called from a running event loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为 Jupyter 已经运行了 事件循环，无需自己激活，采用上文中的 <code>await()</code> 调用即可。</p><p>比如，如下程序：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Jupyter Notebook 和 Python Shell 中分别为：</p><article>    <div class="tab-set w3-light-grey">        <input checked="True" id="tab-set--0-input--1" name="tab-set--0" type="radio">        <label for="tab-set--0-input--1">Jupyter Notebook</label>        <div class="tab-content w3-padding"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">await</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>        </div>        <input id="tab-set--0-input--2" name="tab-set--0" type="radio">        <label for="tab-set--0-input--2">Python Shell</label>        <div class="tab-content w3-padding"><pre class="line-numbers language-python" data-language="python"><code class="language-python">asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>        </div>    </div></article><h2 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a>运行 asyncio 程序</h2><p><code>asyncio.run(coro, *, debug=False)</code> 执行 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-coroutine">coroutine</a> coro 并返回结果。此函数会运行传入的协程，负责管理 <code>asyncio</code> 事件循环，终结异步生成器，并关闭线程池。</p><p>当有其他 <code>asyncio</code> 事件循环在同一线程中运行时，此函数不能被调用。</p><p>如果 <code>debug</code> 为 <code>True</code>，事件循环将以调试模式运行。此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 <code>asyncio</code> 程序的主入口点，理想情况下应当只被调用一次。</p><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p><code>asyncio.create_task(coro, *, name=None)</code> 将 <code>coro</code> 协程 封装为一个 <code>Task</code> 并调度其执行。返回 <code>Task</code> 对象。<code>name</code> 不为 <code>None</code>，它将使用 <code>Task.set_name()</code> 来设为任务的名称。</p><p>该任务会在 <code>get_running_loop()</code> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <code>RuntimeError</code>。此函数 在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p><h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><p>coroutine <code>asyncio.sleep(delay, result=None)</code> 阻塞 <code>delay</code> 指定的秒数。如果指定了 <code>result</code>，则当协程完成时将其返回给调用者。<code>sleep()</code> 总是会挂起当前任务，以允许其他任务运行。</p><p>将 <code>delay</code> 设置为 <code>0</code> 提供了优化的路径，以允许其他任务运行。长时间运行的函数可以使用它来避免在函数调用的整个过程中阻塞事件循环。</p><p>以下协程示例运行 5 秒，每秒显示一次当前日期：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> datetime<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">display_date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>    end_time <span class="token operator">=</span> loop<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5.0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> end_time<span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>display_date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a>并发运行任务</h2><p>awaitable <code>asyncio.gather(*aws, return_exceptions=False)</code> 并发 运行 <code>aws</code> 序列中的 <dfn class="xin-term">可等待对象</dfn>。如果 <code>aws</code> 中的某个可等待对象为<dfn class="xin-term">协程</dfn>，它将自动被作为一个任务调度。如果所有<dfn class="xin-term">可等待对象</dfn>都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <code>aws</code> 中可等待对象的顺序一致。</p><p>如果 <code>return_exceptions</code> 为 <code>False</code> (默认)，所引发的首个异常会立即传播给等待 <code>gather()</code> 的任务。<code>aws</code> 序列中的其他可等待对象 <strong>不会被取消</strong> 并将继续运行。如果 <code>return_exceptions</code> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</p><p>如果 <code>gather()</code> 被取消，所有被提交 (尚未完成) 的可等待对象也会 被取消。如果 <code>aws</code> 序列中的任一 Task 或 Future 对象 被取消，它将被当作引发了 CancelledError 一样处理 – 在此情况下 <code>gather()</code> 调用 不会 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 Tasks/Future 也被取消。</p><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> number <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Task </span><span class="token interpolation"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token string">: Compute factorial(</span><span class="token interpolation"><span class="token punctuation">{</span>i<span class="token punctuation">}</span></span><span class="token string">)..."</span></span><span class="token punctuation">)</span>        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        f <span class="token operator">*=</span> i    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Task </span><span class="token interpolation"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token string">: factorial(</span><span class="token interpolation"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span><span class="token string">) = </span><span class="token interpolation"><span class="token punctuation">{</span>f<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Schedule three calls *concurrently*:</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>        factorial<span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        factorial<span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        factorial<span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><output>Task A: Compute factorial(2)...Task B: Compute factorial(2)...Task C: Compute factorial(2)...Task A: factorial(2) = 2Task B: Compute factorial(3)...Task C: Compute factorial(3)...Task B: factorial(3) = 6Task C: Compute factorial(4)...Task C: factorial(4) = 24</output><h2 id="屏蔽取消操作"><a href="#屏蔽取消操作" class="headerlink" title="屏蔽取消操作"></a>屏蔽取消操作</h2><p>awaitable <code>asyncio.shield(aw)</code> 保护一个 <dfn class="xin-term">可等待对象</dfn> 防止其被 取消。如果 <code>aw</code> 是一个协程，它将自动被作为任务调度。以下语句：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res <span class="token operator">=</span> <span class="token keyword">await</span> shield<span class="token punctuation">(</span>something<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相当于：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res <span class="token operator">=</span> <span class="token keyword">await</span> something<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不同之处：如果包含它的协程被取消，在 <code>something()</code> 中运行的任务不会被取消。从 <code>something()</code> 的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 <code>"await"</code> 表达式仍然会引发 <code>CancelledError</code>。如果通过其他方式取消 <code>something()</code> (例如在其内部操作) 则 <code>shield()</code> 也会取消。如果希望完全忽略取消操作 (不推荐) 则 <code>shield()</code> 函数需要配合一个 <code>try/except</code> 代码段，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> <span class="token keyword">await</span> shield<span class="token punctuation">(</span>something<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> CancelledError<span class="token punctuation">:</span>    res <span class="token operator">=</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>coroutine <code>asyncio.wait_for(aw, timeout)</code> 等待 <code>aw</code> 可等待对象 完成，指定 <code>timeout</code> 秒数后超时。如果 <code>aw</code> 是一个协程，它将自动被作为任务调度。<code>timeout</code> 可以为 <code>None</code>，也可以为 <code>float</code> 或 <code>int</code> 型数值表示的等待秒数。如果 <code>timeout</code> 为 <code>None</code>，则等待直到完成。</p><p>如果发生超时，任务将取消并引发 <code>asyncio.TimeoutError</code>。要避免任务 被取消，可以加上 <code>shield()</code>。此函数将等待直到 <code>Future</code> 确实被取消，所以总等待时间可能超过 <code>timeout</code>。如果在取消期间发生了异常，异常将会被传播。如果等待被取消，则 <code>aw</code> 指定的对象也会被取消。</p><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">eternity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Sleep for one hour</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3600</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'yay!'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Wait for at most 1 second</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>wait_for<span class="token punctuation">(</span>eternity<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>TimeoutError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'timeout!'</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><output>timeout!</output><p>Python 3.8 版后已移除: <code>asyncio.wait</code>，所以尽量使用 <code>asyncio.wait_for</code>。</p><h2 id="as-completed"><a href="#as-completed" class="headerlink" title="as_completed"></a>as_completed</h2><p><code>asyncio.as_completed(aws, *, timeout=None)</code> 并发地运行 <code>aws</code> 可迭代对象中的 可等待对象。返回一个协程的迭代器。所返回的每个协程可被等待以从剩余的可等待对象的可迭代对象中获得最早的下一个结果。</p><p>如果在所有 <code>Future</code> 对象完成前发生超时则将引发 <code>asyncio.TimeoutError</code>。示例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> coro <span class="token keyword">in</span> as_completed<span class="token punctuation">(</span>aws<span class="token punctuation">)</span><span class="token punctuation">:</span>    earliest_result <span class="token operator">=</span> <span class="token keyword">await</span> coro    <span class="token comment"># ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="在线程中运行"><a href="#在线程中运行" class="headerlink" title="在线程中运行"></a>在线程中运行</h2><p><code>coroutine asyncio.to_thread(func, /, *args, **kwargs)</code> 在不同的线程中异步地运行函数 <code>func</code>。</p><p>向此函数提供的任何 <code>*args</code> 和 <code>**kwargs</code> 会被直接传给 <code>func</code>。并且，当前 <code>contextvars.Context</code> 会被传播，允许在不同的线程中访问来自事件循环的上下文变量。返回一个可被等待以获取 <code>func</code> 的最终结果的协程。</p><p>这个协程函数主要是用于执行在其他情况下会阻塞事件循环的 IO 密集型函数/方法。例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">blocking_io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"start blocking_io at </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token comment"># Note that time.sleep() can be replaced with any blocking</span>    <span class="token comment"># IO-bound operation, such as file operations.</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"blocking_io complete at </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"started main at </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>        asyncio<span class="token punctuation">.</span>to_thread<span class="token punctuation">(</span>blocking_io<span class="token punctuation">)</span><span class="token punctuation">,</span>        asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"finished main at </span><span class="token interpolation"><span class="token punctuation">{</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><output>started main at 14:55:04start blocking_io at 14:55:04blocking_io complete at 14:55:05finished main at 14:55:05</output><p>在任何协程中直接调用 <code>blocking_io()</code> 将会在调用期间阻塞事件循环，导致额外的 1 秒运行时间。而通过改用 <code>asyncio.to_thread()</code>，我们可以在不同的线程中运行它从而不会阻塞事件循环。</p><h2 id="跨线程调度"><a href="#跨线程调度" class="headerlink" title="跨线程调度"></a>跨线程调度</h2><p><code>asyncio.run_coroutine_threadsafe(coro, loop)</code> 向指定事件循环提交一个协程。（线程安全）</p><p>返回一个 <code>concurrent.futures.Future</code> 以等待来自其他 OS 线程的结果。</p><p>此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Create a coroutine</span>coro <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> result<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment"># Submit the coroutine to a given loop</span>future <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>run_coroutine_threadsafe<span class="token punctuation">(</span>coro<span class="token punctuation">,</span> loop<span class="token punctuation">)</span><span class="token comment"># Wait for the result with an optional timeout argument</span><span class="token keyword">assert</span> future<span class="token punctuation">.</span>result<span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> future<span class="token punctuation">.</span>result<span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>TimeoutError<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The coroutine took too long, cancelling the task...'</span><span class="token punctuation">)</span>    future<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> exc<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'The coroutine raised an exception: </span><span class="token interpolation"><span class="token punctuation">{</span>exc<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'The coroutine returned: </span><span class="token interpolation"><span class="token punctuation">{</span>result<span class="token conversion-option punctuation">!r</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同与其他 <code>asyncio</code> 函数，此函数要求显式地传入 <code>loop</code> 参数。</p><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p><code>asyncio.current_task(loop=None)</code> 返回当前运行的 <code>Task</code> 实例，如果没有正在运行的任务则返回 <code>None</code>。如果 <code>loop</code> 为 <code>None</code> 则会使用 <code>asyncio.get_running_loop()</code> 获取当前事件循环。</p><p><code>asyncio.all_tasks(loop=None)</code> 返回事件循环所运行的未完成的 <code>Task</code> 对象的集合。如果 <code>loop</code> 为 <code>None</code>，则会使用 <code>asyncio.get_running_loop()</code> 获取当前事件循环。</p><h2 id="Task-对象"><a href="#Task-对象" class="headerlink" title="Task 对象"></a>Task 对象</h2><p><code>class asyncio.Task(coro, *, name=None)</code> 与 <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future">Future 类似</a>，可运行 Python 协程。非线程安全。</p><p>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 <code>Future</code> 对象，<code>Task</code> 对象会挂起该协程的执行并等待该 <code>Future</code> 对象完成。当该 <code>Future</code> 对象 完成，被打包的协程将恢复执行。事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 Task、回调或执行 IO 操作。</p><p>使用高层级的 <code>asyncio.create_task()</code> 函数来创建 <code>Task</code> 对象，也可用低层级的 <code>asyncio.loop.create_task()</code> 或 <code>asyncio.ensure_future()</code> 函数。不建议手动实例化 <code>Task</code> 对象。</p><p>要取消一个正在运行的 <code>Task</code> 对象可使用 <code>asyncio.Task.cancel()</code> 方法。调用此方法将使该 <code>Task</code> 对象抛出一个 <code>CancelledError</code> 异常给打包的协程。如果取消期间一个协程正在等待一个 <code>Future</code> 对象，该 <code>Future</code> 对象也将被取消。</p><p><code>asyncio.Task.cancelled()</code> 可被用来检测 <code>Task</code> 对象是否被取消。如果打包的协程没有抑制 <code>CancelledError</code> 异常并且确实被取消，该方法将返回 <code>True</code>。</p><p><code>asyncio.Task</code> 从 <code>Future</code> 继承了其除 <code>Future.set_result()</code> 和 <code>Future.set_exception()</code> 以外的所有 API。</p><p><code>Task</code> 对象支持 <a href="https://docs.python.org/zh-cn/3/library/contextvars.html#module-contextvars">contextvars</a> 模块。当一个 <code>Task</code> 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。</p><h3 id="cancel-msg-None"><a href="#cancel-msg-None" class="headerlink" title="cancel(msg=None)"></a><code>cancel(msg=None)</code></h3><p>请求取消 <code>Task</code> 对象。这将安排在下一轮事件循环中抛出一个 <code>CancelledError</code> 异常给被封包的协程。协程在之后有机会进行清理甚至使用 <code>try ... ... except CancelledError ... finally</code> 代码块抑制异常来拒绝请求。不同于 <code>Future.cancel()</code>，<code>Task.cancel()</code> 不保证 <code>Task</code> 会被取消，虽然抑制完全取消并不常见，也很不鼓励这样做。</p><p>以下示例演示了协程是如何侦听取消请求的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">cancel_me</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cancel_me(): before sleep'</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment"># Wait for 1 hour</span>        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3600</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>CancelledError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cancel_me(): cancel sleep'</span><span class="token punctuation">)</span>        <span class="token keyword">raise</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cancel_me(): after sleep'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Create a "cancel_me" Task</span>    task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>cancel_me<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># Wait for 1 second</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    task<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">await</span> task    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>CancelledError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"main(): cancel_me is cancelled now"</span><span class="token punctuation">)</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><output>cancel_me(): before sleepcancel_me(): cancel sleepcancel_me(): after sleepmain(): cancel_me is cancelled now</output><h3 id="cancelled"><a href="#cancelled" class="headerlink" title="cancelled()"></a><code>cancelled()</code></h3><p>如果 <code>Task</code> 对象 被取消 则返回 <code>True</code>。当使用 <code>cancel()</code> 发出取消请求时 <code>Task</code> 会被 取消，其封包的协程将传播被抛入的 <code>CancelledError</code> 异常。</p><h3 id="done"><a href="#done" class="headerlink" title="done()"></a><code>done()</code></h3><p>如果 <code>Task</code> 对象 已完成 则返回 <code>True</code>。当 <code>Task</code> 所封包的协程返回一个值、引发一个异常或 <code>Task</code> 本身被取消时，则会被认为 已完成。</p><h3 id="result"><a href="#result" class="headerlink" title="result()"></a><code>result()</code></h3><p>返回 <code>Task</code> 的结果。如果 <code>Task</code> 对象 已完成，其封包的协程的结果会被返回 (或者当协程引发异常时，该异常会被重新引发)。如果 <code>Task</code> 对象 被取消，此方法会引发一个 <code>CancelledError</code> 异常。如果 <code>Task</code> 对象的结果还不可用，此方法会引发一个 <code>InvalidStateError</code> 异常。</p><h3 id="exception"><a href="#exception" class="headerlink" title="exception()"></a><code>exception()</code></h3><p>返回 <code>Task</code> 对象的异常。如果所封包的协程引发了一个异常，该异常将被返回。如果所封包的协程正常返回则该方法将返回 <code>None</code>。如果 <code>Task</code> 对象 被取消，此方法会引发一个 <code>CancelledError</code> 异常。如果 <code>Task</code> 对象尚未 完成，此方法将引发一个 <code>InvalidStateError</code> 异常。</p><h3 id="add-done-callback-callback-context-None"><a href="#add-done-callback-callback-context-None" class="headerlink" title="add_done_callback(callback, *, context=None)"></a><code>add_done_callback(callback, *, context=None)</code></h3><p>添加一个回调，将在 <code>Task</code> 对象 完成 时被运行。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future.add_done_callback">Future.add_done_callback()</a> 的文档。</p><h3 id="remove-done-callback-callback"><a href="#remove-done-callback-callback" class="headerlink" title="remove_done_callback(callback)"></a><code>remove_done_callback(callback)</code></h3><p>从回调列表中移除 <code>callback</code> 指定的回调。此方法应该仅在低层级的基于回调的代码中使用。</p><p>要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future.remove_done_callback">Future.remove_done_callback()</a> 的文档。</p><h3 id="get-stack-limit-None"><a href="#get-stack-limit-None" class="headerlink" title="get_stack(*, limit=None)"></a><code>get_stack(*, limit=None)</code></h3><p>返回此 <code>Task</code> 对象的栈 frame 列表。如果所封包的协程未完成，这将返回其挂起所在的栈。如果协程已成功完成或被取消，这将返回一个空列表。如果协程被一个异常终止，这将返回回溯 frame 列表。</p><p>frame 总是从按从旧到新排序。</p><p>每个被挂起的协程只返回一个栈 frame。</p><p>可选的 <code>limit</code> 参数指定返回 frame 的数量上限；默认返回所有 frame。返回列表的顺序要看是返回一个栈还是一个回溯：栈返回最新的 frame，回溯返回最旧的frame。(这与 traceback 模块的行为保持一致。)</p><h3 id="print-stack-limit-None-file-None"><a href="#print-stack-limit-None-file-None" class="headerlink" title="print_stack(*, limit=None, file=None)"></a><code>print_stack(*, limit=None, file=None)</code></h3><p>打印此 <code>Task</code> 对象的栈或回溯。</p><p>此方法产生的输出类似于 traceback 模块通过 get_stack() 所获取的框架。</p><p><code>limit</code> 参数会直接传递给 <code>get_stack()</code>。</p><p><code>file</code> 参数是输出所写入的 I/O 流；默认情况下输出会写入 <code>sys.stderr</code>。</p><h3 id="get-coro"><a href="#get-coro" class="headerlink" title="get_coro()"></a><code>get_coro()</code></h3><p>返回由 Task 包装的协程对象。</p><h3 id="get-name"><a href="#get-name" class="headerlink" title="get_name()"></a>get_name()</h3><p>返回 Task 的名称。</p><p>如果没有一个 Task 名称被显式地赋值，默认的 asyncio Task 实现会在实例化期间生成一个默认名称。</p><h4 id="set-name-value"><a href="#set-name-value" class="headerlink" title="set_name(value)"></a><code>set_name(value)</code></h4><p>设置 Task 的名称。</p><p><code>value</code> 参数可以为任意对象，它随后会被转换为字符串。</p><p>在默认的 Task 实现中，名称将在任务对象的 <code>repr()</code> 输出中可见</p>]]></content:encoded>
      
      
      <category domain="https://xinetzone.github.io/categories/Python-%E7%BC%96%E7%A8%8B/">Python 编程</category>
      
      
      <category domain="https://xinetzone.github.io/tags/asyncio/">asyncio</category>
      
      
      <comments>https://xinetzone.github.io/post/zh-CN/bc778a9a2e3c.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
